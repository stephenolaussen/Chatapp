<!DOCTYPE html>
<html lang="no">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="description" content="Familieskatt - Chat rom">
    <meta name="theme-color" content="#667eea">
    <title>Familie chat - <%- room %></title>
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" type="image/svg+xml" href="/icons/favicon.svg">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
      html {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        background: #f5f5f7;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        color: #1d1d1f;
        overflow: hidden;
      }

      .header {
        background: white;
        padding: 0.75rem 1rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: nowrap;
        position: sticky;
        top: 0;
        z-index: 50;
        border-bottom: 1px solid #e5e5e7;
      }

      .header-left {
        display: flex;
        align-items: center;
        gap: 0.3rem;
        flex: 1;
        min-width: 0;
      }

      .header-left h1 {
        font-size: 1rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
      }

      .header-left a {
        flex-shrink: 0;
      }

      .online-users {
        display: flex;
        align-items: center;
        gap: 0.3rem;
        flex-shrink: 0;
        font-size: 0.9rem;
        color: #666;
        margin-top: 0.5rem;
      }

      .online-count {
        background: #34c759;
        color: white;
        padding: 0.35rem 1rem;
        border-radius: 25px;
        font-weight: 600;
        font-size: 0.85rem;
        box-shadow: 0 2px 8px rgba(52, 199, 89, 0.2);
      }

      .user-list {
        display: none;
        position: absolute;
        top: 60px;
        right: 10px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
        max-height: 350px;
        overflow-y: auto;
        z-index: 100;
        min-width: 220px;
        border: 1px solid #e5e5e7;
      }

      .user-list.show {
        display: block;
      }

      .user-list-item {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #f0f0f0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .user-list-item:last-child {
        border-bottom: none;
      }

      .user-badge {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #43e97b;
      }

      .user-list-item-name {
        font-weight: 500;
        color: #333;
      }

      .header h1 {
        font-size: 1.5rem;
        color: #333;
        flex-grow: 1;
        text-align: center;
        font-weight: 600;
        letter-spacing: -0.5px;
      }

      .header a {
        color: #0071e3;
        text-decoration: none;
        font-size: 1.2rem;
        transition: all 0.2s;
        padding: 0.5rem;
        border-radius: 8px;
      }

      .header a:hover {
        color: #0071e3;
        background: #f5f5f7;
      }

      .user-info {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        background: var(--user-color, #0071e3);
        color: white;
        padding: 0.6rem 1.2rem;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 2px 8px rgba(0, 113, 227, 0.15);
        font-weight: 500;
      }

      .user-info:hover {
        opacity: 0.9;
        box-shadow: 0 4px 12px rgba(0, 113, 227, 0.25);
      }

      #messages {
        list-style-type: none;
        flex-grow: 1;
        overflow-y: auto;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        background: white;
      }

      #messages > li {
        display: flex;
        flex-direction: column;
        max-width: 80%;
        word-wrap: break-word;
        position: relative;
      }

      #messages > li.own-message {
        align-self: flex-end;
        max-width: 80%;
      }

      .message-actions {
        display: none;
        position: absolute;
        top: 0.5rem;
        right: -2.5rem;
        gap: 0.5rem;
        z-index: 10;
      }

      #messages > li.own-message .message-actions {
        display: flex;
      }

      .message-actions button {
        background: #0071e3;
        border: none;
        color: white;
        width: 1.8rem;
        height: 1.8rem;
        border-radius: 50%;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 113, 227, 0.2);
      }

      .message-actions button:hover {
        background: #0071e3;
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(0, 113, 227, 0.3);
      }

      .message-bubble {
        padding: 0.85rem 1.2rem;
        border-radius: 18px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        animation: fadeIn 0.3s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      #messages > li.own-message .message-bubble {
        background: var(--user-color, #0071e3);
        color: white;
        border-bottom-right-radius: 3px;
      }

      #messages > li:not(.own-message) .message-bubble {
        background: var(--message-color, #e8e8ed);
        color: #1d1d1f;
        border-bottom-left-radius: 3px;
      }

      .message-sender {
        font-weight: bold;
        font-size: 0.85rem;
        margin-bottom: 0.3rem;
        display: flex;
        align-items: center;
        gap: 0.3rem;
      }

      #messages > li:not(.own-message) .message-sender {
        color: #555;
      }

      #messages > li.own-message .message-sender {
        color: rgba(255, 255, 255, 0.8);
        justify-content: flex-end;
      }

      .message-time {
        font-size: 0.75rem;
        opacity: 0.6;
      }

      .message-reactions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        margin-top: 0.5rem;
        align-items: center;
      }

      .reaction-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
        background: rgba(0, 113, 227, 0.08);
        border: 1px solid rgba(0, 113, 227, 0.2);
        padding: 0.25rem 0.5rem;
        border-radius: 12px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.15s;
        user-select: none;
      }

      .reaction-pill:hover {
        background: rgba(0, 113, 227, 0.15);
        border-color: rgba(0, 113, 227, 0.3);
      }

      .reaction-pill.active {
        background: rgba(0, 113, 227, 0.25);
        border-color: rgba(0, 113, 227, 0.5);
      }

      .reaction-emoji {
        font-size: 0.95rem;
      }

      .reaction-count {
        font-size: 0.8rem;
        color: #666;
        font-weight: 500;
      }

      .add-reaction-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        background: rgba(0, 113, 227, 0.08);
        border: 1px solid rgba(0, 113, 227, 0.2);
        border-radius: 12px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.15s;
        padding: 0;
        margin-left: 0.2rem;
      }

      .add-reaction-btn:hover {
        background: rgba(0, 113, 227, 0.15);
      }

      .reaction-picker {
        position: absolute;
        bottom: calc(100% + 5px);
        left: 0;
        background: white;
        border-radius: 12px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        display: none;
        grid-template-columns: repeat(5, 1fr);
        gap: 0.3rem;
        z-index: 1000;
        border: 1px solid #e5e5e7;
        white-space: nowrap;
      }

      .reaction-picker.show {
        display: grid;
      }

      .reaction-picker-emoji {
        font-size: 1.3rem;
        cursor: pointer;
        padding: 0.4rem;
        border-radius: 8px;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .reaction-picker-emoji:hover {
        background: rgba(0, 113, 227, 0.1);
        transform: scale(1.2);
      }

      #form {
        background: white;
        padding: 1.2rem;
        display: flex;
        gap: 0.75rem;
        box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.08);
        border-top: 1px solid #e5e5e7;
      }

      #input {
        border: 1px solid #d5d5d7;
        padding: 0.85rem 1.2rem;
        flex-grow: 1;
        border-radius: 28px;
        font-size: 1rem;
        transition: all 0.2s;
        background: #f5f5f7;
      }

      #input:focus {
        outline: none;
        border-color: #0071e3;
        background: white;
        box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.1);
      }

      #form > button {
        background: #0071e3;
        border: none;
        padding: 0.85rem 1.8rem;
        border-radius: 28px;
        color: white;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s;
        font-size: 1rem;
        box-shadow: 0 2px 8px rgba(0, 113, 227, 0.2);
      }

      #form > button:hover {
        opacity: 0.9;
        box-shadow: 0 4px 12px rgba(0, 113, 227, 0.3);
      }

      #form > button:active {
        transform: translateY(0);
      }

      .emoji-btn {
        background: white;
        border: 1px solid #d5d5d7;
        padding: 0.6rem 1rem;
        border-radius: 25px;
        cursor: pointer;
        font-size: 1.3rem;
        transition: all 0.2s;
      }

      .emoji-btn:hover {
        border-color: #0071e3;
        background: #f5f5f7;
        transform: scale(1.05);
      }

      .emoji-btn:active {
        transform: scale(0.95);
      }

      .alarm-btn {
        background: #ff3b30;
        border: none;
        padding: 0.3rem 0.6rem;
        border-radius: 18px;
        color: white;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
        font-size: 0.7rem;
        box-shadow: 0 2px 8px rgba(255, 59, 48, 0.2);
        flex-shrink: 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .alarm-btn:hover {
        opacity: 0.9;
        box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
      }

      .alarm-btn:active {
        transform: scale(0.95);
      }

      /* Modal styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(2px);
      }

      .modal.show {
        display: flex;
      }

      /* Password modal should be completely opaque */
      #passwordModal {
        background-color: rgba(0, 0, 0, 0.95);
      }

      .modal-content {
        background-color: white;
        padding: 2.5rem;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 420px;
        width: 90%;
        animation: slideIn 0.3s ease;
        border: 1px solid #e5e5e7;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      @keyframes alarm-flash {
        0%, 100% {
          background: #f5f5f7;
        }
        50% {
          background: #ff3b30;
        }
      }

      .modal h2 {
        margin-bottom: 2rem;
        color: #333;
        font-size: 1.5rem;
        font-weight: 600;
      }

      .form-group {
        margin-bottom: 1.5rem;
      }

      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: bold;
        color: #555;
      }

      .form-group input[type="text"],
      .form-group input[type="color"] {
        width: 100%;
        padding: 0.85rem 1rem;
        border: 1px solid #d5d5d7;
        border-radius: 10px;
        font-size: 1rem;
        transition: all 0.2s;
        background: #f5f5f7;
      }

      .form-group input[type="text"]:focus,
      .form-group input[type="color"]:focus {
        outline: none;
        border-color: #0071e3;
        background: white;
        box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.1);
      }

      .color-options {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 0.5rem;
        margin-bottom: 1rem;
      }

      .color-option {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        border: 3px solid transparent;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .color-option:hover {
        transform: scale(1.12);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .color-option.selected {
        border-color: #333;
        box-shadow: 0 0 0 2px white, 0 0 0 4px #333, 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .modal-buttons {
        display: flex;
        gap: 1rem;
      }

      .modal-buttons button {
        flex: 1;
        padding: 0.9rem;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
      }

      .btn-primary {
        background: #0071e3;
        color: white;
        box-shadow: 0 2px 8px rgba(0, 113, 227, 0.15);
      }

      .btn-primary:hover {
        opacity: 0.9;
        box-shadow: 0 4px 12px rgba(0, 113, 227, 0.25);
      }

      .btn-secondary {
        background: #e0e0e0;
        color: #333;
      }

      .btn-secondary:hover {
        background: #d0d0d0;
      }

      /* Emoji picker */
      .emoji-picker {
        position: fixed;
        bottom: 80px;
        right: 10px;
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
        padding: 1.2rem;
        display: none;
        grid-template-columns: repeat(6, 1fr);
        gap: 0.6rem;
        max-width: 320px;
        z-index: 500;
        border: 1px solid #e5e5e7;
        overflow: hidden;
      }

      .emoji-picker.show {
        display: grid;
      }

      .emoji-picker span {
        font-size: 1.6rem;
        cursor: pointer;
        padding: 0.65rem;
        border-radius: 8px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .emoji-picker span:hover {
        background: rgba(0, 113, 227, 0.1);
        transform: scale(1.15);
      }

      /* System messages */
      .system-message {
        padding: 0.5rem 1rem;
        text-align: center;
        color: #999;
        font-size: 0.9rem;
        align-self: center;
      }

      /* Edit message modal */
      .edit-modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        align-items: center;
        justify-content: center;
      }

      .edit-modal.show {
        display: flex;
      }

      .edit-modal-content {
        background-color: white;
        padding: 2.5rem;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 420px;
        width: 90%;
        animation: slideIn 0.3s ease;
        border: 1px solid #e5e5e7;
      }

      .edit-modal h2 {
        margin-bottom: 1.5rem;
        color: #333;
        font-size: 1.5rem;
        font-weight: 600;
      }

      .edit-textarea {
        width: 100%;
        padding: 0.85rem 1rem;
        border: 1px solid #d5d5d7;
        border-radius: 10px;
        font-size: 1rem;
        font-family: inherit;
        resize: vertical;
        min-height: 100px;
        margin-bottom: 1.5rem;
        transition: all 0.2s;
      }

      .edit-textarea:focus {
        outline: none;
        border-color: #0071e3;
        background: white;
        box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.1);
      }

      #gameCanvas {
        display: block;
        background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 100%);
        border: none;
        margin: 0 auto;
        width: 100%;
        max-width: 400px;
        height: auto;
      }

      .game-modal {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        align-items: center;
        justify-content: center;
      }

      .game-modal.show {
        display: flex;
      }

      .game-modal-content {
        background-color: white;
        padding: 2rem;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        max-width: 450px;
        width: 90%;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .game-modal-content h2 {
        margin-bottom: 1rem;
        color: #333;
      }

      .game-stats {
        display: flex;
        justify-content: space-around;
        margin: 1rem 0;
        padding: 1rem;
        background: #f9fafb;
        border-radius: 10px;
        gap: 1rem;
      }

      .game-stat {
        flex: 1;
      }

      .game-stat-label {
        font-size: 0.85rem;
        color: #666;
        margin-bottom: 0.3rem;
      }

      .game-stat-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #667eea;
      }

      .game-instructions {
        background: #f0f4ff;
        padding: 1rem;
        border-radius: 10px;
        margin: 1rem 0;
        font-size: 0.95rem;
        color: #555;
      }

      .game-buttons {
        display: flex;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .game-buttons button {
        flex: 1;
        padding: 0.8rem;
        border: none;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.95rem;
      }

      .btn-play {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-play:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .btn-close-game {
        background: #e5e7eb;
        color: #333;
      }

      .btn-close-game:hover {
        background: #d1d5db;
      }

      .btn-game-select {
        padding: 1rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
      }

      .btn-game-select:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      #snakeCanvas {
        border: 2px solid #667eea;
        background: #f0f0f0;
        border-radius: 8px;
        margin: 1rem auto;
        display: block;
        width: 100%;
        max-width: 400px;
        height: auto;
      }

      #ballCanvas {
        border: 2px solid #764ba2;
        background: #f0f0f0;
        border-radius: 8px;
        margin: 1rem auto;
        display: block;
        width: 100%;
        max-width: 400px;
        height: auto;
      }

      #pongCanvas {
        border: 2px solid #43e97b;
        background: #f0f0f0;
        border-radius: 8px;
        margin: 1rem auto;
        display: block;
        width: 100%;
        max-width: 400px;
        height: auto;
      }

      #dodgeCanvas {
        border: 2px solid #fa709a;
        background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 8px;
        margin: 1rem auto;
        display: block;
        width: 100%;
        max-width: 400px;
        height: auto;
      }

      @media (max-width: 600px) {
        * {
          -webkit-touch-callout: none;
          -webkit-user-select: none;
          user-select: none;
        }

        input, textarea, button {
          -webkit-user-select: text;
          user-select: text;
          -webkit-touch-callout: default;
        }

        html {
          height: 100%;
        }

        body {
          overflow: hidden;
          height: 100%;
          display: flex;
          flex-direction: column;
          width: 100%;
        }

        #messages > li,
        #messages > li.own-message {
          max-width: 95%;
        }

        .header {
          flex-direction: column;
          gap: 0.5rem;
          padding: 0.75rem 0.75rem;
          flex-shrink: 0;
        }

        .header h1 {
          font-size: 1.2rem;
        }

        .header-left {
          width: 100%;
          justify-content: space-between;
        }

        .online-users {
          position: absolute;
          right: 1rem;
          top: 3.5rem;
        }

        .user-info {
          padding: 0.5rem 1rem;
          font-size: 0.9rem;
        }

        #messages {
          flex: 1;
          min-height: 0;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
          padding: 1rem 0.75rem;
        }

        #form {
          padding: 0.75rem;
          gap: 0.5rem;
          flex-wrap: nowrap;
          flex-shrink: 0;
          position: relative;
          z-index: 10;
          background: rgba(255, 255, 255, 0.92);
        }

        #form > button,
        .emoji-btn {
          flex-shrink: 0;
          white-space: nowrap;
          pointer-events: auto;
        }

        #input {
          min-width: 0;
          padding: 0.7rem 1rem;
          font-size: 16px;
          pointer-events: auto;
          -webkit-appearance: none;
          appearance: none;
          border-radius: 8px;
        }

        .emoji-btn {
          padding: 0.5rem 0.75rem;
          font-size: 1.2rem;
        }

        #form > button {
          padding: 0.7rem 1.2rem;
          font-size: 0.9rem;
        }

        .emoji-picker {
          position: fixed;
          bottom: 65px;
          right: 0;
          left: 0;
          max-width: none;
          width: 100%;
          max-height: 200px;
          grid-template-columns: repeat(5, 1fr);
          border-radius: 20px 20px 0 0;
          padding: 1rem;
          overflow-y: auto;
        }

        .user-list {
          top: 50px;
          right: 5px;
          left: 5px;
          max-width: none;
        }

        .game-modal-content {
          max-width: 95vw;
          width: 95vw;
          padding: 1.5rem;
          max-height: 90vh;
          overflow-y: auto;
        }

        #snakeCanvas,
        #ballCanvas,
        #gameCanvas {
          width: 100% !important;
          max-width: calc(95vw - 3rem) !important;
          height: auto !important;
        }

        .game-instructions {
          font-size: 0.85rem;
          padding: 0.75rem;
        }

        .game-buttons {
          flex-direction: column;
          gap: 0.75rem;
        }

        .game-stat-value {
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="header-left">
        <a href="/" title="Back to home"><i class="fas fa-arrow-left"></i></a>
        <h1>üí¨ Familie chat - <%- room %></h1>
        <button onclick="sendAlarm()" class="alarm-btn" title="Send alarm to all">üîî</button>
      </div>
      <div class="online-users">
        <button onclick="openGameModal()" style="background: none; border: none; cursor: pointer; color: #667eea; font-size: 1.2rem; padding: 0;" title="Play Flappy Bird">
          üéÆ
        </button>
        <span class="online-count" id="userCount">1</span>
        <button onclick="toggleUserList()" style="background: none; border: none; cursor: pointer; color: #667eea; font-size: 1.2rem; padding: 0;" title="Online users">
          <i class="fas fa-users"></i>
        </button>
      </div>
      <div class="user-list" id="userList"></div>
      <div class="user-info" id="userInfo" onclick="showUserModal()">
        <span id="userName">User</span>
        <i class="fas fa-edit"></i>
      </div>
    </div>

    <!-- User setup modal -->
    <div id="userModal" class="modal">
      <div class="modal-content">
        <h2>üéâ Choose Your Name and Color</h2>
        
        <div class="form-group">
          <label for="nameInput">Your name:</label>
          <input type="text" id="nameInput" placeholder="Enter your name..." maxlength="20">
        </div>

        <div class="form-group">
          <label>Choose a color:</label>
          <div class="color-options">
            <div class="color-option" style="background: #667eea;" data-color="#667eea"></div>
            <div class="color-option" style="background: #f093fb;" data-color="#f093fb"></div>
            <div class="color-option" style="background: #4facfe;" data-color="#4facfe"></div>
            <div class="color-option" style="background: #43e97b;" data-color="#43e97b"></div>
            <div class="color-option" style="background: #fa709a;" data-color="#fa709a"></div>
            <div class="color-option" style="background: #fee140;" data-color="#fee140"></div>
            <div class="color-option" style="background: #30b0fe;" data-color="#30b0fe"></div>
            <div class="color-option" style="background: #ec77de;" data-color="#ec77de"></div>
          </div>
          <input type="color" id="colorInput">
        </div>

        <div class="modal-buttons">
          <button class="btn-primary" onclick="saveUserInfo()">Save</button>
        </div>
      </div>
    </div>

    <!-- Password modal -->
    <div id="passwordModal" class="modal">
      <div class="modal-content">
        <h2>üîí Enter Password</h2>
        <p style="color: #666; margin-bottom: 1.5rem; text-align: center;">This room requires a password</p>
        
        <div class="form-group">
          <label for="passwordInput">Password:</label>
          <input type="password" id="passwordInput" placeholder="Enter password..." autocomplete="off">
        </div>

        <div class="modal-buttons">
          <button class="btn-primary" onclick="verifyPassword()">Enter</button>
          <button class="btn-secondary" onclick="goBack()">Back</button>
        </div>
      </div>
    </div>

    <ul id="messages"></ul>

    <!-- Game Modal -->
    <div id="gameModal" class="game-modal">
      <div class="game-modal-content">
        <!-- Game Menu -->
        <div id="gameMenu" style="display: block;">
          <h2>üéÆ Velg Spill</h2>
          <div style="display: flex; flex-direction: column; gap: 1rem;">
            <button class="btn-game-select" onclick="selectGame('flappybird')">
              üê¶ Flappy Bird
            </button>
            <button class="btn-game-select" onclick="selectGame('snake')">
              üêç Snake
            </button>
            <button class="btn-game-select" onclick="selectGame('bouncingball')">
              üéæ Bouncing Ball
            </button>
            <button class="btn-game-select" onclick="selectGame('pong')">
              üèì Pong
            </button>
            <button class="btn-game-select" onclick="selectGame('dodge')">
              üöó Dodge
            </button>
          </div>
          <button class="btn-close-game" onclick="closeGameModal()" style="margin-top: 1rem; width: 100%;">Lukk</button>
        </div>

        <!-- Flappy Bird Game -->
        <div id="flappybirdGame" style="display: none;">
          <h2>üê¶ Flappy Bird</h2>
          <canvas id="gameCanvas" width="400" height="300"></canvas>
          <div class="game-stats">
            <div class="game-stat">
              <div class="game-stat-label">Score</div>
              <div class="game-stat-value" id="gameScore">0</div>
            </div>
            <div class="game-stat">
              <div class="game-stat-label">Highscore</div>
              <div class="game-stat-value" id="gameHighscore">0</div>
            </div>
          </div>
          <div class="game-instructions">
            <strong>Tap/Click to make the bird fly!</strong><br>
            Avoid the pipes and get the highest score!
          </div>
          <div class="game-buttons">
            <button class="btn-play" onclick="startGame()">Play</button>
            <button class="btn-close-game" onclick="backToGameMenu()">Tilbake</button>
          </div>
        </div>

        <!-- Snake Game -->
        <div id="snakeGame" style="display: none;">
          <style>
            .snake-container {
              background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
              border-radius: 12px;
              padding: 1rem;
              max-width: 500px;
              margin: 0 auto;
              box-shadow: 0 8px 32px rgba(102, 126, 234, 0.2);
              display: flex;
              flex-direction: column;
            }
            
            .snake-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 0.5rem;
              flex-wrap: wrap;
              gap: 0.5rem;
            }
            
            .snake-header h2 {
              margin: 0;
              font-size: 1.5rem;
              background: linear-gradient(135deg, #00FF00, #00CC88);
              -webkit-background-clip: text;
              -webkit-text-fill-color: transparent;
              background-clip: text;
            }
            
            .snake-stats {
              display: flex;
              gap: 0.75rem;
              margin-bottom: 0.5rem;
              justify-content: space-around;
              flex-wrap: wrap;
            }
            
            .snake-stat-box {
              background: rgba(102, 126, 234, 0.15);
              padding: 0.5rem;
              border-radius: 6px;
              border-left: 2px solid #667eea;
              text-align: center;
              min-width: 90px;
              flex: 1;
            }
            
            .snake-stat-box .label {
              font-size: 0.7rem;
              color: #aaa;
              text-transform: uppercase;
              letter-spacing: 0.5px;
            }
            
            .snake-stat-box .value {
              font-size: 1.3rem;
              font-weight: bold;
              color: #00FF00;
              margin-top: 0.2rem;
            }
            
            .snake-difficulty {
              text-align: center;
              margin: 0.3rem 0;
              font-size: 0.75rem;
              color: #aaa;
            }
            
            .difficulty-bar {
              width: 100%;
              height: 6px;
              background: #333;
              border-radius: 3px;
              margin-top: 0.5rem;
              overflow: hidden;
            }
            
            .difficulty-fill {
              height: 100%;
              background: linear-gradient(90deg, #00FF00, #FFD700, #FF6B6B);
              width: 25%;
              transition: width 0.3s ease;
            }
            
            .snake-canvas-wrapper {
              position: relative;
              text-align: center;
              margin-bottom: 0.5rem;
              max-height: 300px;
              display: flex;
              align-items: center;
              justify-content: center;
            }
            
            #snakeCanvas {
              display: block;
              border: 2px solid #667eea;
              border-radius: 8px;
              cursor: crosshair;
              touch-action: none;
              background: #1a1a2e;
              box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
              width: 100%;
              height: 100%;
              max-width: 400px;
              max-height: 400px;
            }
            
            .snake-controls {
              text-align: center;
              margin-bottom: 0.3rem;
            }
            
            .snake-play-btn {
              background: linear-gradient(135deg, #00FF00, #00CC88);
              color: #1a1a2e;
              border: none;
              padding: 0.6rem 1.5rem;
              font-size: 0.9rem;
              font-weight: bold;
              border-radius: 6px;
              cursor: pointer;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
            }
            
            .snake-play-btn:hover {
              transform: translateY(-2px);
              box-shadow: 0 6px 20px rgba(0, 255, 0, 0.5);
            }
            
            .snake-play-btn:active {
              transform: translateY(0);
            }
            
            .snake-instructions {
              background: rgba(102, 126, 234, 0.1);
              padding: 0.5rem;
              border-radius: 6px;
              font-size: 0.75rem;
              color: #bbb;
              text-align: center;
              margin-bottom: 0.5rem;
            }
            
            .snake-controls-hint {
              color: #00FF00;
              font-weight: bold;
              margin-top: 0.5rem;
            }
            
            .snake-gameover-overlay {
              position: fixed;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              background: rgba(0, 0, 0, 0.8);
              display: flex;
              align-items: center;
              justify-content: center;
              z-index: 10000;
              backdrop-filter: blur(4px);
            }
            
            .snake-gameover-box {
              background: linear-gradient(135deg, #1a1a2e, #16213e);
              padding: 2rem;
              border-radius: 12px;
              text-align: center;
              border: 2px solid #667eea;
              box-shadow: 0 8px 32px rgba(0, 255, 0, 0.2);
            }
            
            .snake-gameover-box h3 {
              font-size: 2rem;
              color: #FF6B6B;
              margin-bottom: 1rem;
            }
            
            .snake-gameover-stats {
              margin: 1.5rem 0;
            }
            
            .snake-gameover-stat {
              font-size: 1.1rem;
              margin: 0.5rem 0;
              color: #bbb;
            }
            
            .snake-gameover-stat .stat-value {
              color: #00FF00;
              font-weight: bold;
            }
            
            .snake-gameover-buttons {
              display: flex;
              gap: 1rem;
              justify-content: center;
              margin-top: 1.5rem;
              flex-wrap: wrap;
            }
            
            .btn-retry {
              background: linear-gradient(135deg, #00FF00, #00CC88);
              color: #1a1a2e;
              border: none;
              padding: 0.75rem 1.5rem;
              font-weight: bold;
              border-radius: 6px;
              cursor: pointer;
              transition: all 0.3s ease;
            }
            
            .btn-retry:hover {
              transform: scale(1.05);
            }
            
            .btn-back {
              background: #667eea;
              color: white;
              border: none;
              padding: 0.75rem 1.5rem;
              font-weight: bold;
              border-radius: 6px;
              cursor: pointer;
              transition: all 0.3s ease;
            }
            
            .btn-back:hover {
              transform: scale(1.05);
            }
          </style>
          
          <div class="snake-container">
            <div class="snake-header">
              <h2>üêç Snake</h2>
            </div>
            
            <div class="snake-stats">
              <div class="snake-stat-box">
                <div class="label">Score</div>
                <div class="value" id="snakeScore">0</div>
              </div>
              <div class="snake-stat-box">
                <div class="label">Highscore</div>
                <div class="value" id="snakeHighscore">0</div>
              </div>
              <div class="snake-stat-box">
                <div class="label">Length</div>
                <div class="value" id="snakeLength">1</div>
              </div>
            </div>
            
            <div class="snake-difficulty">
              Difficulty: <span id="snakeDifficultyText">Easy</span>
              <div class="difficulty-bar">
                <div class="difficulty-fill" id="difficultyFill"></div>
              </div>
            </div>
            
            <div class="snake-instructions">
              <div>Swipe or use <span class="snake-controls-hint">Arrow Keys / WASD</span></div>
              <div style="margin-top: 0.3rem; font-size: 0.8rem;">Eat the red circles to grow!</div>
            </div>
            
            <div class="snake-canvas-wrapper">
              <canvas id="snakeCanvas" width="400" height="400"></canvas>
            </div>
            
            <div class="snake-controls">
              <button class="snake-play-btn" onclick="startSnakeGame()" id="snakePlayBtn">‚ñ∂Ô∏è Play</button>
            </div>
            
            <div style="text-align: center;">
              <button class="btn-close-game" onclick="backToGameMenu()" style="margin-top: 1rem;">‚¨ÖÔ∏è Tilbake</button>
            </div>
          </div>
          
          <!-- Game Over Overlay -->
          <div class="snake-gameover-overlay" id="snakeGameOverOverlay" style="display: none;">
            <div class="snake-gameover-box">
              <h3>Game Over!</h3>
              <div class="snake-gameover-stats">
                <div class="snake-gameover-stat">Final Score: <span class="stat-value" id="finalScore">0</span></div>
                <div class="snake-gameover-stat">Snake Length: <span class="stat-value" id="finalLength">1</span></div>
              </div>
              <div id="newHighscoreMsg" style="color: #FFD700; font-weight: bold; margin: 1rem 0; font-size: 1.2rem; display: none;">
                üèÜ NEW HIGHSCORE! üèÜ
              </div>
              <div class="snake-gameover-buttons">
                <button class="btn-retry" onclick="startSnakeGame()">üîÑ Try Again</button>
                <button class="btn-back" onclick="backToGameMenu()">‚¨ÖÔ∏è Back</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Bouncing Ball Game -->
        <div id="bouncingBallGame" style="display: none;">
          <h2>üéæ Bouncing Ball</h2>
          <canvas id="ballCanvas" width="400" height="400"></canvas>
          <div class="game-stats">
            <div class="game-stat">
              <div class="game-stat-label">Score</div>
              <div class="game-stat-value" id="ballScore">0</div>
            </div>
            <div class="game-stat">
              <div class="game-stat-label">Highscore</div>
              <div class="game-stat-value" id="ballHighscore">0</div>
            </div>
          </div>
          <div class="game-instructions">
            <strong>Mouse/Touch to move paddle</strong><br>
            Keep the ball from falling!
          </div>
          <div class="game-buttons">
            <button class="btn-play" onclick="startBouncingBallGame()">Play</button>
            <button class="btn-close-game" onclick="backToGameMenu()">Tilbake</button>
          </div>
        </div>

        <!-- Pong Game -->
        <div id="pongGame" style="display: none;">
          <style>
            .pong-container {
              background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
              border-radius: 12px;
              padding: 1.5rem;
              max-width: 500px;
              margin: 0 auto;
              box-shadow: 0 8px 32px rgba(67, 233, 123, 0.2);
              display: flex;
              flex-direction: column;
            }
            
            @media (max-width: 600px) {
              .pong-container {
                padding: 1rem;
                max-width: 100%;
              }
            }
            
            .pong-header {
              text-align: center;
              margin-bottom: 1rem;
            }
            
            .pong-header h2 {
              margin: 0;
              font-size: 1.8rem;
              background: linear-gradient(135deg, #43e97b, #38b86d);
              -webkit-background-clip: text;
              -webkit-text-fill-color: transparent;
              background-clip: text;
            }
            
            .pong-canvas-wrapper {
              position: relative;
              margin-bottom: 1rem;
              border: 3px solid #43e97b;
              border-radius: 8px;
              overflow: visible;
              box-shadow: 0 0 30px rgba(67, 233, 123, 0.3), inset 0 0 20px rgba(67, 233, 123, 0.1);
              width: 100%;
              max-width: 406px;
              aspect-ratio: 1;
              margin-left: auto;
              margin-right: auto;
              flex-shrink: 0;
              box-sizing: border-box;
            }
            
            @media (max-width: 600px) {
              .pong-canvas-wrapper {
                max-width: 100%;
                max-height: 70vh;
                margin-bottom: 0.5rem;
              }
            }
            
            #pongCanvas {
              display: block;
              width: 100%;
              height: 100%;
              background: #0a0a0f;
            }
            
            .pong-stats {
              display: flex;
              gap: 1rem;
              margin-bottom: 1rem;
              justify-content: center;
            }
            
            .pong-stat-box {
              background: rgba(67, 233, 123, 0.1);
              padding: 0.75rem 1.5rem;
              border-radius: 8px;
              border: 2px solid #43e97b;
              text-align: center;
              min-width: 120px;
            }
            
            .pong-stat-label {
              font-size: 0.8rem;
              color: #aaa;
              text-transform: uppercase;
              letter-spacing: 0.5px;
              margin-bottom: 0.3rem;
            }
            
            .pong-stat-value {
              font-size: 1.8rem;
              font-weight: bold;
              color: #43e97b;
              text-shadow: 0 0 10px rgba(67, 233, 123, 0.5);
            }
            
            .pong-instructions {
              background: rgba(67, 233, 123, 0.1);
              padding: 0.75rem;
              border-radius: 6px;
              font-size: 0.85rem;
              color: #bbb;
              text-align: center;
              margin-bottom: 1rem;
              border-left: 3px solid #43e97b;
            }
            
            .pong-controls {
              text-align: center;
              margin-bottom: 1rem;
            }
            
            .btn-pong-play {
              background: linear-gradient(135deg, #43e97b, #38b86d);
              color: #0a0a0f;
              border: none;
              padding: 0.75rem 2rem;
              font-size: 1rem;
              font-weight: bold;
              border-radius: 8px;
              cursor: pointer;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(67, 233, 123, 0.4);
            }
            
            .btn-pong-play:hover {
              transform: translateY(-2px);
              box-shadow: 0 6px 25px rgba(67, 233, 123, 0.6);
            }
            
            .btn-pong-play:active {
              transform: translateY(0);
            }
          </style>
          
          <div class="pong-container">
            <div class="pong-header">
              <h2>üèì Pong</h2>
            </div>
            
            <div class="pong-canvas-wrapper">
              <canvas id="pongCanvas" width="400" height="400"></canvas>
            </div>
            
            <div class="pong-stats">
              <div class="pong-stat-box">
                <div class="pong-stat-label">Your Score</div>
                <div class="pong-stat-value" id="pongScore">0</div>
              </div>
              <div class="pong-stat-box">
                <div class="pong-stat-label">Highscore</div>
                <div class="pong-stat-value" id="pongHighscore">0</div>
              </div>
            </div>
            
            <div class="pong-instructions">
              <strong>üéÆ Arrow Keys or W/S to move paddle</strong><br>
              <span style="font-size: 0.9rem;">Beat the AI! Score by making them miss!</span>
            </div>
            
            <!-- Mobile Controls -->
            <div id="pongMobileControls" style="display: none; margin: 1rem 0;">
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; max-width: 200px; margin: 0 auto;">
                <button style="padding: 1rem; background: linear-gradient(135deg, #43e97b, #38b86d); color: #0a0a0f; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1.3rem; box-shadow: 0 4px 15px rgba(67, 233, 123, 0.3);" onclick="handlePongMobileControl('up')">‚¨ÜÔ∏è UP</button>
                <button style="padding: 1rem; background: linear-gradient(135deg, #43e97b, #38b86d); color: #0a0a0f; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1.3rem; box-shadow: 0 4px 15px rgba(67, 233, 123, 0.3);" onclick="handlePongMobileControl('down')">‚¨áÔ∏è DOWN</button>
              </div>
            </div>
            
            <div class="pong-controls">
              <button class="btn-pong-play" onclick="startPongGame()">‚ñ∂Ô∏è Play</button>
            </div>
            
            <div style="text-align: center;">
              <button class="btn-close-game" onclick="backToGameMenu()" style="margin-top: 0.5rem;">‚¨ÖÔ∏è Tilbake</button>
            </div>
          </div>
        </div>

        <!-- Dodge Game -->
        <div id="dodgeGame" style="display: none;">
          <h2>üöó Dodge</h2>
          <canvas id="dodgeCanvas" width="400" height="400"></canvas>
          <div class="game-stats">
            <div class="game-stat">
              <div class="game-stat-label">Score</div>
              <div class="game-stat-value" id="dodgeScore">0</div>
            </div>
            <div class="game-stat">
              <div class="game-stat-label">Highscore</div>
              <div class="game-stat-value" id="dodgeHighscore">0</div>
            </div>
          </div>
          <div class="game-instructions">
            <strong>Arrow Keys or A/D to move</strong><br>
            Dodge the obstacles! Collect power-ups!
          </div>
          <!-- Mobile Controls -->
          <div id="dodgeMobileControls" style="display: none; margin: 1rem 0;">
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; max-width: 150px; margin: 0 auto;">
              <button style="padding: 0.75rem; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1.2rem;" onclick="handleDodgeMobileControl('left')">‚¨ÖÔ∏è LEFT</button>
              <button style="padding: 0.75rem; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1.2rem;" onclick="handleDodgeMobileControl('right')">‚û°Ô∏è RIGHT</button>
            </div>
          </div>
          <div class="game-buttons">
            <button class="btn-play" onclick="startDodgeGame()">Play</button>
            <button class="btn-close-game" onclick="backToGameMenu()">Tilbake</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Edit message modal -->
    <div id="editModal" class="edit-modal">
      <div class="edit-modal-content">
        <h2>‚úèÔ∏è Edit Message</h2>
        <textarea id="editTextarea" class="edit-textarea" placeholder="Edit your message..."></textarea>
        <div class="modal-buttons">
          <button class="btn-primary" onclick="saveEditMessage()">Save</button>
          <button class="btn-secondary" onclick="closeEditModal()">Cancel</button>
        </div>
      </div>
    </div>

    <form id="form" action="">
      <button type="button" class="emoji-btn" onclick="toggleEmojiPicker()">üòä</button>
      <div class="emoji-picker" id="emojiPicker">
        <span onclick="insertEmoji('üòÄ')">üòÄ</span>
        <span onclick="insertEmoji('üòÇ')">üòÇ</span>
        <span onclick="insertEmoji('üòç')">üòç</span>
        <span onclick="insertEmoji('ü§î')">ü§î</span>
        <span onclick="insertEmoji('üò±')">üò±</span>
        <span onclick="insertEmoji('üéâ')">üéâ</span>
        <span onclick="insertEmoji('üëç')">üëç</span>
        <span onclick="insertEmoji('üëé')">üëé</span>
        <span onclick="insertEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</span>
        <span onclick="insertEmoji('üòò')">üòò</span>
        <span onclick="insertEmoji('üôè')">üôè</span>
        <span onclick="insertEmoji('üî•')">üî•</span>
        <span onclick="insertEmoji('üíØ')">üíØ</span>
        <span onclick="insertEmoji('üéà')">üéà</span>
        <span onclick="insertEmoji('üçï')">üçï</span>
        <span onclick="insertEmoji('‚öΩ')">‚öΩ</span>
        <span onclick="insertEmoji('üì±')">üì±</span>
        <span onclick="insertEmoji('‚ú®')">‚ú®</span>
      </div>
      <input id="input" autocomplete="off" placeholder="Write a message..."/>
      <button>Send</button>
    </form>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Register service worker and check for updates
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('/sw.js').then(registration => {
            // Check for updates every 30 seconds
            setInterval(() => {
              registration.update().catch(err => console.log('Update check failed:', err));
            }, 30000);

            // Listen for service worker updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // Show update prompt
                  if (confirm('üîÑ En ny versjon av appen er tilgjengelig! Vil du oppdatere n√•?')) {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                    window.location.reload();
                  }
                }
              });
            });
          }).catch(err => console.log('SW registration failed:', err));
        }

        const room = '<%-room%>';
        const userModal = document.getElementById('userModal');
        const passwordModal = document.getElementById('passwordModal');
        const nameInput = document.getElementById('nameInput');
        const colorInput = document.getElementById('colorInput');
        const passwordInput = document.getElementById('passwordInput');
        const userInfo = document.getElementById('userInfo');
        const userName = document.getElementById('userName');
        const colorOptions = document.querySelectorAll('.color-option');
        const userList = document.getElementById('userList');
        const userCount = document.getElementById('userCount');
        const editModal = document.getElementById('editModal');
        const editTextarea = document.getElementById('editTextarea');
        
        let currentEditMessageElement = null;
        
        let currentUser = {
          name: localStorage.getItem('chatUserName') || '',
          color: localStorage.getItem('chatUserColor') || '#667eea'
        };

        let onlineUsers = {};

        let socket = io('/admin');
        let form = document.getElementById('form');
        let input = document.getElementById('input');
        let messagesList = document.getElementById('messages');

        // Check for password protection on page load
        async function checkRoomPassword() {
          try {
            const response = await fetch('/verify-password', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ room: room, password: null })
            });
            const data = await response.json();
            
            // If room requires password, show password modal
            if (data.message === 'Incorrect password' || (data.success === false && data.message !== 'Incorrect password')) {
              passwordModal.classList.add('show');
              passwordInput.focus();
              // Disable form and messages
              form.style.pointerEvents = 'none';
              form.style.opacity = '0.5';
              messagesList.style.pointerEvents = 'none';
              messagesList.style.opacity = '0.5';
            }
          } catch (err) {
            console.log('Password check error:', err);
          }
        }

        // Verify password
        async function verifyPassword() {
          const password = passwordInput.value;
          if (!password) {
            alert('Please enter a password');
            return;
          }

          try {
            const response = await fetch('/verify-password', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ room: room, password: password })
            });
            const data = await response.json();
            
            if (data.success) {
              passwordModal.classList.remove('show');
              form.style.pointerEvents = 'auto';
              form.style.opacity = '1';
              messagesList.style.pointerEvents = 'auto';
              messagesList.style.opacity = '1';
              passwordInput.value = '';
            } else {
              alert('Incorrect password');
              passwordInput.value = '';
              passwordInput.focus();
            }
          } catch (err) {
            alert('Error verifying password');
            console.log('Verification error:', err);
          }
        }

        // Go back to home
        function goBack() {
          window.location.href = '/';
        }

        // Allow Enter key to submit password
        if (passwordInput) {
          passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              verifyPassword();
            }
          });
        }

        // Toggle user list
        function toggleUserList() {
          userList.classList.toggle('show');
        }

        // Close user list on click outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.online-users') && !e.target.closest('.user-list')) {
            userList.classList.remove('show');
          }
        });

        // Update online user list
        function updateUserList() {
          userList.innerHTML = '';
          let count = 0;
          for (const [socketId, user] of Object.entries(onlineUsers)) {
            count++;
            const item = document.createElement('div');
            item.className = 'user-list-item';
            item.innerHTML = `
              <div class="user-badge" style="background: ${user.color}"></div>
              <span class="user-list-item-name">${user.name}</span>
            `;
            userList.appendChild(item);
          }
          userCount.textContent = count;
        }

        // Apply user info from localStorage
        function initializeUser() {
          if (!currentUser.name) {
            showUserModal();
          } else {
            updateUserDisplay();
          }
        }

        // Show user modal
        function showUserModal() {
          userModal.classList.add('show');
          nameInput.value = currentUser.name;
          colorInput.value = currentUser.color;
          updateColorSelection();
          nameInput.focus();
        }

        // Hide user modal
        function hideUserModal() {
          userModal.classList.remove('show');
        }

        // Save user info
        function saveUserInfo() {
          const name = nameInput.value.trim();
          if (!name) {
            alert('Please enter your name');
            return;
          }
          currentUser.name = name;
          currentUser.color = colorInput.value;
          localStorage.setItem('chatUserName', currentUser.name);
          localStorage.setItem('chatUserColor', currentUser.color);
          hideUserModal();
          updateUserDisplay();
          
          // Join room with updated user info
          if (socket.connected) {
            socket.emit('join', { 
              room: room,
              name: currentUser.name,
              color: currentUser.color
            });
          }
        }

        // Update user display
        function updateUserDisplay() {
          userName.textContent = currentUser.name;
          userInfo.style.setProperty('--user-color', currentUser.color);
          document.documentElement.style.setProperty('--user-color', currentUser.color);
          
          // Fetch all available rooms and send to Service Worker
          fetch('/api/rooms').then(response => response.json()).then(data => {
            if (data.success && data.rooms && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {
              // Send all available rooms to service worker for background polling
              // Service Worker will now notify user for messages in ANY room, even when app is closed
              navigator.serviceWorker.controller.postMessage({
                type: 'UPDATE_ROOMS_INFO',
                rooms: data.rooms,
                user: currentUser.name
              });
            }
          }).catch(err => console.log('Failed to fetch rooms for SW:', err));
          
          // Legacy: Also send individual room update for backward compatibility
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage({
              type: 'UPDATE_ROOM_INFO',
              room: room,
              user: currentUser.name
            });
          }
        }

        // Color selection
        function updateColorSelection() {
          colorOptions.forEach(option => {
            if (option.dataset.color === colorInput.value) {
              option.classList.add('selected');
            } else {
              option.classList.remove('selected');
            }
          });
        }

        colorOptions.forEach(option => {
          option.addEventListener('click', () => {
            colorInput.value = option.dataset.color;
            updateColorSelection();
          });
        });

        colorInput.addEventListener('change', updateColorSelection);

        // Emoji picker
        function toggleEmojiPicker() {
          const picker = document.getElementById('emojiPicker');
          picker.classList.toggle('show');
        }

        function insertEmoji(emoji) {
          input.value += emoji;
          input.focus();
        }

        // Close emoji picker on click outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.emoji-btn') && !e.target.closest('.emoji-picker')) {
            document.getElementById('emojiPicker').classList.remove('show');
          }
        });

        // Edit message functions
        function editMessage(messageElement) {
          currentEditMessageElement = messageElement;
          const messageText = messageElement.querySelector('.message-bubble > div:first-child').textContent;
          editTextarea.value = messageText;
          editModal.classList.add('show');
          editTextarea.focus();
          editTextarea.select();
        }

        function closeEditModal() {
          editModal.classList.remove('show');
          currentEditMessageElement = null;
          editTextarea.value = '';
        }

        function saveEditMessage() {
          const newText = editTextarea.value.trim();
          if (!newText) {
            alert('Message cannot be empty');
            return;
          }

          // Update the message in UI
          const messageContent = currentEditMessageElement.querySelector('.message-bubble > div:first-child');
          messageContent.textContent = newText;
          
          // Emit update to server
          socket.emit('edit message', {
            room: room,
            sender: currentUser.name,
            newText: newText
          });

          closeEditModal();
        }

        // Close edit modal on click outside
        editModal.addEventListener('click', (e) => {
          if (e.target === editModal) {
            closeEditModal();
          }
        });

        // Allow Ctrl+Enter to save
        editTextarea.addEventListener('keydown', (e) => {
          if (e.ctrlKey && e.key === 'Enter') {
            saveEditMessage();
          }
        });

        // Socket events - Form submit handler
        form.addEventListener('submit', function(e) {
          e.preventDefault();
          if (!input.value.trim()) return;
          
          if (!socket.connected) {
            alert('Not connected to chat. Refreshing...');
            window.location.reload();
            return;
          }
          
          const msg = input.value.trim();
          socket.emit('chat message', { 
            msg, 
            room,
            sender: currentUser.name,
            color: currentUser.color
          });
          input.value = '';
          document.getElementById('emojiPicker').classList.remove('show');
        });

        socket.on('chat message', function(data) {
          const item = document.createElement('li');
          
          // Check if it's a system message (like highscore)
          if (typeof data === 'object' && data.isSystemMessage) {
            item.classList.add('system-message');
            item.style.color = data.color || '#FFD700';
            item.style.fontWeight = 'bold';
            item.style.fontSize = '1.1rem';
            item.textContent = data.text || data.msg;
          }
          // Check if it's a message object or plain text
          else if (typeof data === 'object' && data.text) {
            const reactionsHtml = data.reactions && Object.keys(data.reactions).length > 0 
              ? `<div class="message-reactions" data-timestamp="${data.timestamp}" style="position: relative;">
                   ${Object.entries(data.reactions).map(([emoji, users]) => {
                     const isActive = users.includes(currentUser.name);
                     return `<span class="reaction-pill ${isActive ? 'active' : ''}" onclick="toggleReaction(event, '${emoji}')"><span class="reaction-emoji">${emoji}</span><span class="reaction-count">${users.length}</span></span>`;
                   }).join('')}
                   <button class="add-reaction-btn" onclick="toggleReactionPicker(event)" title="Add reaction">‚ûï</button>
                   <div class="reaction-picker" onclick="event.stopPropagation()">
                     <span class="reaction-picker-emoji" onclick="addReaction('üëç', this)">üëç</span>
                     <span class="reaction-picker-emoji" onclick="addReaction('‚ù§Ô∏è', this)">‚ù§Ô∏è</span>
                     <span class="reaction-picker-emoji" onclick="addReaction('üòÇ', this)">üòÇ</span>
                     <span class="reaction-picker-emoji" onclick="addReaction('üî•', this)">üî•</span>
                     <span class="reaction-picker-emoji" onclick="addReaction('üòç', this)">üòç</span>
                   </div>
                 </div>`
              : `<div class="message-reactions" data-timestamp="${data.timestamp}" style="position: relative;">
                   <button class="add-reaction-btn" onclick="toggleReactionPicker(event)" title="Add reaction">‚ûï</button>
                   <div class="reaction-picker" onclick="event.stopPropagation()">
                     <span class="reaction-picker-emoji" onclick="addReaction('üëç', this)">üëç</span>
                     <span class="reaction-picker-emoji" onclick="addReaction('‚ù§Ô∏è', this)">‚ù§Ô∏è</span>
                     <span class="reaction-picker-emoji" onclick="addReaction('üòÇ', this)">üòÇ</span>
                     <span class="reaction-picker-emoji" onclick="addReaction('üî•', this)">üî•</span>
                     <span class="reaction-picker-emoji" onclick="addReaction('üòç', this)">üòç</span>
                   </div>
                 </div>`;
            
            item.innerHTML = `
              <div class="message-sender">
                <span>${data.sender || 'User'}</span>
              </div>
              <div class="message-bubble">
                <div>${data.text}</div>
                <div class="message-time">${new Date().toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'})}</div>
              </div>
              ${reactionsHtml}
            `;
            item.dataset.messageTime = data.timestamp;
            if (data.sender === currentUser.name) {
              item.classList.add('own-message');
              // Add edit actions for own messages
              const actionsDiv = document.createElement('div');
              actionsDiv.className = 'message-actions';
              actionsDiv.innerHTML = `
                <button title="Edit message" onclick="editMessage(this.closest('li'))">
                  <i class="fas fa-edit"></i>
                </button>
              `;
              item.appendChild(actionsDiv);
            }
            if (data.color) {
              item.style.setProperty('--message-color', data.color);
            }
          } else {
            // System message
            item.classList.add('system-message');
            item.textContent = data.toString();
          }
          
          messagesList.appendChild(item);
          
          // Send notification for new message (only if page is NOT visible)
          if (typeof data === 'object' && data.text && data.sender !== currentUser.name && !data.isSystemMessage && !pageVisible) {
            sendNotification(data.sender, data.text);
          }
          
          // Scroll to bottom
          scrollToBottom();
        });

        // Scroll messages to bottom
        function scrollToBottom() {
          messagesList.scrollTop = messagesList.scrollHeight;
        }

        // Toggle reaction picker
        function toggleReactionPicker(event) {
          event.stopPropagation();
          const picker = event.target.closest('.message-reactions').querySelector('.reaction-picker');
          // Close all other pickers
          document.querySelectorAll('.reaction-picker.show').forEach(p => {
            if (p !== picker) p.classList.remove('show');
          });
          picker.classList.toggle('show');
        }

        // Add reaction
        function addReaction(emoji, element) {
          const messageElement = element.closest('li');
          const messageTime = messageElement.dataset.messageTime;
          
          socket.emit('add reaction', {
            room: room,
            messageTime: messageTime,
            emoji: emoji,
            user: currentUser.name
          });
          
          element.closest('.reaction-picker').classList.remove('show');
        }

        // Toggle reaction (add or remove)
        function toggleReaction(event, emoji) {
          event.stopPropagation();
          const messageElement = event.target.closest('li');
          const messageTime = messageElement.dataset.messageTime;
          const isActive = event.target.closest('.reaction-pill').classList.contains('active');
          
          if (isActive) {
            socket.emit('remove reaction', {
              room: room,
              messageTime: messageTime,
              emoji: emoji,
              user: currentUser.name
            });
          } else {
            socket.emit('add reaction', {
              room: room,
              messageTime: messageTime,
              emoji: emoji,
              user: currentUser.name
            });
          }
        }

        // Handle reaction updates
        socket.on('reaction updated', function(data) {
          // Find all messages with this timestamp and update reactions
          document.querySelectorAll(`li[data-message-time="${data.messageTime}"] .message-reactions`).forEach(reactionsDiv => {
            const picker = reactionsDiv.querySelector('.reaction-picker');
            let html = '';
            if (data.reactions && Object.keys(data.reactions).length > 0) {
              html = Object.entries(data.reactions).map(([emoji, users]) => {
                const isActive = users.includes(currentUser.name);
                return `<span class="reaction-pill ${isActive ? 'active' : ''}" onclick="toggleReaction(event, '${emoji}')"><span class="reaction-emoji">${emoji}</span><span class="reaction-count">${users.length}</span></span>`;
              }).join('');
            }
            html += '<button class="add-reaction-btn" onclick="toggleReactionPicker(event)" title="Add reaction">‚ûï</button>';
            reactionsDiv.innerHTML = html;
            if (picker) {
              reactionsDiv.appendChild(picker);
            }
          });
        });

        // Close reaction picker when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.reaction-picker') && !e.target.closest('.add-reaction-btn')) {
            document.querySelectorAll('.reaction-picker.show').forEach(p => p.classList.remove('show'));
          }
        });

        socket.on('user left', function(data) {
          if (onlineUsers[data.socketId]) {
            delete onlineUsers[data.socketId];
            updateUserList();
          }
        });

        socket.on('users list', function(data) {
          // Single source of truth from server - replace entire list
          onlineUsers = data || {};
          updateUserList();
        });

        socket.on('message edited', function(data) {
          // Find and update the message in the DOM
          const messages = messagesList.querySelectorAll('li');
          messages.forEach(msg => {
            const senderElement = msg.querySelector('.message-sender span');
            if (senderElement && senderElement.textContent === data.sender) {
              const messageContent = msg.querySelector('.message-bubble > div:first-child');
              if (messageContent) {
                messageContent.textContent = data.newText;
              }
            }
          });
        });

        // Handle socket disconnection and reconnection
        socket.on('disconnect', () => {
          console.log('Disconnected from server');
        });

        socket.on('connect', () => {
          console.log('Connected to server');
          socket.emit('join', { 
            room: room,
            name: currentUser.name,
            color: currentUser.color
          });
          
          // Scroll to bottom after loading initial messages
          setTimeout(() => {
            scrollToBottom();
          }, 100);
        });

        socket.on('connect_error', (error) => {
          console.error('Connection error:', error);
        });

        // Track if page is visible/focused
        let pageVisible = document.visibilityState === 'visible';
        
        // Debounce notifications
        let notificationTimeout = null;
        let pendingNotification = null;
        const NOTIFICATION_DEBOUNCE_MS = 3000; // Batch multiple messages within 3 seconds
        
        // Track page visibility
        document.addEventListener('visibilitychange', () => {
          pageVisible = document.visibilityState === 'visible';
          // Tell service worker about visibility state (for smarter polling)
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage({
              type: 'PAGE_VISIBILITY',
              visible: pageVisible
            });
          }
          
          // Clear badge when page becomes visible
          if (pageVisible && 'clearAppBadge' in navigator) {
            try {
              navigator.clearAppBadge();
            } catch(e) {}
          }
        });
        
        // Also clear badge when page initially loads
        if ('clearAppBadge' in navigator && document.visibilityState === 'visible') {
          try {
            navigator.clearAppBadge();
          } catch(e) {}
        }

        // Request notification permission and subscribe to push
        function requestNotificationPermission() {
          if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
              if (permission === 'granted') {
                subscribeToPush();
              }
            });
          } else if ('Notification' in window && Notification.permission === 'granted') {
            // Already granted, subscribe to push
            subscribeToPush();
          }
        }

        // Subscribe to Web Push notifications
        async function subscribeToPush() {
          if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
            console.log('Web Push not supported');
            return;
          }

          try {
            const registration = await navigator.serviceWorker.ready;
            
            // Get VAPID public key from server
            const keyResponse = await fetch('/vapid-public-key');
            const { publicKey, enabled } = await keyResponse.json();
            
            if (!enabled || !publicKey) {
              console.log('Web Push not enabled on server');
              return;
            }
            
            // Convert VAPID key to Uint8Array
            function urlBase64ToUint8Array(base64String) {
              const padding = '='.repeat((4 - base64String.length % 4) % 4);
              const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
              const rawData = window.atob(base64);
              const outputArray = new Uint8Array(rawData.length);
              for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
              }
              return outputArray;
            }

            // Subscribe to push
            const subscription = await registration.pushManager.subscribe({
              userVisibleOnly: true,
              applicationServerKey: urlBase64ToUint8Array(publicKey)
            });

            // Send subscription to server with user email
            const subscriptionData = {
              ...subscription.toJSON(),
              email: (typeof currentUser !== 'undefined' && currentUser.email) ? currentUser.email : null
            };

            const response = await fetch('/subscribe', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(subscriptionData)
            });

            if (response.ok) {
              console.log('‚úÖ Push subscription registered');
            } else {
              console.log('Failed to register subscription');
            }
          } catch (err) {
            console.log('Push subscription failed:', err);
          }
        }

        // Keep Service Worker alive with periodic heartbeat (prevents SW termination)
        if ('serviceWorker' in navigator) {
          setInterval(() => {
            if (navigator.serviceWorker.controller) {
              navigator.serviceWorker.controller.postMessage({
                type: 'HEARTBEAT',
                timestamp: Date.now()
              });
            }
          }, 30000); // Every 30 seconds
        }

        // Play notification sound
        function playNotificationSound() {
          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Double beep: high then low
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
          } catch(e) {
            console.log('Could not play sound:', e);
          }
        }

        // Vibrate device
        function vibrateDevice() {
          if ('vibrate' in navigator) {
            try {
              navigator.vibrate([200, 100, 200]);
            } catch(e) {
              console.log('Vibration failed:', e);
            }
          }
        }

        // Update badge count
        function updateBadge(count) {
          if ('setAppBadge' in navigator) {
            try {
              if (count > 0) {
                navigator.setAppBadge(count);
              } else {
                navigator.clearAppBadge();
              }
            } catch(e) {}
          }
        }

        // Send notification for new message
        function sendNotification(sender, message) {
          if ('Notification' in window && Notification.permission === 'granted') {
            // Don't show notification for own messages
            if (sender === currentUser.name) return;
            
            // Store the latest notification
            pendingNotification = { sender, message };
            
            // Clear existing debounce timer
            if (notificationTimeout) {
              clearTimeout(notificationTimeout);
            }
            
            // Set new debounce timer - only show notification if no new messages for 3 seconds
            notificationTimeout = setTimeout(() => {
              if (pendingNotification) {
                const { sender: finalSender, message: finalMessage } = pendingNotification;
                showNotificationNow(finalSender, finalMessage);
                pendingNotification = null;
              }
              notificationTimeout = null;
            }, NOTIFICATION_DEBOUNCE_MS);
          }
        }

        // Actually show the notification
        function showNotificationNow(sender, message) {
          // Only show if page is NOT visible AND if we're not currently in active chat
          if (pageVisible) {
            console.log('Not showing notification - page is visible');
            return;
          }
          
          // Play sound and vibrate
          playNotificationSound();
          vibrateDevice();
          
          // Try to use Service Worker for notifications (better on mobile and works when page is closed)
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage({
              type: 'SHOW_NOTIFICATION',
              title: `üí¨ ${sender}`,
              options: {
                body: message.substring(0, 100),
                icon: '/icons/icon-192.png',
                badge: '/icons/icon-192.png',
                tag: `chat-message-${Date.now()}`,
                requireInteraction: false,
                vibrate: [200, 100, 200]
              }
            });
          } else {
            // Fallback to regular Notification API
            new Notification(`üí¨ ${sender}`, {
              body: message.substring(0, 100),
              icon: '/icons/favicon.svg',
              badge: '/icons/favicon.svg',
              tag: `chat-message-${Date.now()}`,
              requireInteraction: false,
              vibrate: [200, 100, 200]
            });
          }
        }

        // Send alarm to all users
        function sendAlarm() {
          const confirmAlarm = confirm('üö® Send ALARM to all users in this room? Everyone will get a high-priority notification!');
          if (confirmAlarm) {
            socket.emit('alarm', {
              room: room,
              sender: currentUser.name,
              timestamp: new Date()
            });
          }
        }

        // Handle incoming alarm
        socket.on('alarm', function(data) {
          // Show alarm notification with high priority
          if ('Notification' in window && Notification.permission === 'granted') {
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
              navigator.serviceWorker.controller.postMessage({
                type: 'SHOW_ALARM',
                title: `üö® ALARM from ${data.sender}!`,
                options: {
                  body: 'ALARM! Check the chat immediately!',
                  icon: '/icons/icon-192.png',
                  badge: '/icons/icon-192.png',
                  tag: `alarm-${Date.now()}`,
                  requireInteraction: true,
                  silent: false,
                  urgency: 'high'
                }
              });
            } else {
              new Notification(`üö® ALARM from ${data.sender}!`, {
                body: 'ALARM! Check the chat immediately!',
                icon: '/icons/favicon.svg',
                badge: '/icons/favicon.svg',
                tag: `alarm-${Date.now()}`,
                requireInteraction: true,
                silent: false
              });
            }
          }
          
          // Add system message to chat
          const item = document.createElement('li');
          item.classList.add('system-message');
          item.style.color = '#ff6b6b';
          item.style.fontWeight = 'bold';
          item.style.fontSize = '1.1rem';
          item.textContent = `üö® ${data.sender} sent an ALARM!`;
          messagesList.appendChild(item);
          
          // Flash the screen
          document.body.style.animation = 'none';
          setTimeout(() => {
            document.body.style.animation = 'alarm-flash 0.5s ease-in-out';
          }, 10);
        });

        // ============ BOUNCING BALL GAME ============
        let ballGameState = {
          canvas: document.getElementById('ballCanvas'),
          ctx: null,
          paddle: {x: 175, y: 380, width: 50, height: 12, speed: 8},
          ball: {x: 200, y: 200, radius: 6, vx: 3, vy: -3},
          score: 0,
          highscore: localStorage.getItem('ballHighscore') || 0,
          running: false,
          gameRunning: false,
          bricks: [],
          brickRows: 5,
          brickCols: 10,
          level: 1,
          bricksDestroyed: 0,
          totalBricks: 0,
          brickColors: ['#FF6B6B', '#FFA726', '#FFD93D', '#6BCB77', '#4D96FF', '#9D6BE8', '#FF69B4', '#00CEC9', '#74B9FF', '#A29BFE']
        };

        ballGameState.ctx = ballGameState.canvas.getContext('2d');

        function initBallGame() {
          ballGameState.bricks = [];
          const brickWidth = Math.floor(ballGameState.canvas.width / ballGameState.brickCols);
          const brickHeight = 16;
          const startY = 30;
          
          // Create colorful brick rows - more rows for classic breakout feel
          const rowsPerLevel = 4 + Math.floor(ballGameState.level / 2);
          const maxRows = 7;
          const rows = Math.min(rowsPerLevel, maxRows);
          
          for (let row = 0; row < rows; row++) {
            const colorIndex = row % ballGameState.brickColors.length;
            const color = ballGameState.brickColors[colorIndex];
            
            for (let col = 0; col < ballGameState.brickCols; col++) {
              ballGameState.bricks.push({
                x: col * brickWidth,
                y: row * (brickHeight + 4) + startY,
                width: brickWidth - 2,
                height: brickHeight,
                active: true,
                color: color
              });
            }
          }
          
          ballGameState.totalBricks = ballGameState.bricks.length;
          ballGameState.bricksDestroyed = 0;
        }

        function startBouncingBallGame() {
          ballGameState.score = 0;
          ballGameState.running = true;
          ballGameState.gameRunning = true;
          ballGameState.level = 1;
          ballGameState.paddle = {x: 175, y: 380, width: 50, height: 12, speed: 8};
          // Increase ball speed per level
          const baseSpeed = 3.5 + (ballGameState.level - 1) * 0.7;
          ballGameState.ball = {x: 200, y: 300, radius: 6, vx: baseSpeed * 0.7, vy: -baseSpeed};
          document.getElementById('ballScore').textContent = '0';
          
          initBallGame();
          
          // Mouse/touch tracking
          document.addEventListener('mousemove', handleBallMouseMove);
          document.addEventListener('touchmove', handleBallTouchMove);
          
          ballGameLoop();
        }

        function handleBallMouseMove(e) {
          if (!ballGameState.running) return;
          const rect = ballGameState.canvas.getBoundingClientRect();
          const scaleX = ballGameState.canvas.width / rect.width;
          const x = (e.clientX - rect.left) * scaleX;
          ballGameState.paddle.x = Math.max(0, Math.min(x - ballGameState.paddle.width / 2, ballGameState.canvas.width - ballGameState.paddle.width));
        }

        function handleBallTouchMove(e) {
          if (!ballGameState.running) return;
          const rect = ballGameState.canvas.getBoundingClientRect();
          const scaleX = ballGameState.canvas.width / rect.width;
          const x = (e.touches[0].clientX - rect.left) * scaleX;
          ballGameState.paddle.x = Math.max(0, Math.min(x - ballGameState.paddle.width / 2, ballGameState.canvas.width - ballGameState.paddle.width));
        }

        function ballGameLoop() {
          if (!ballGameState.running) return;

          // Update ball position
          ballGameState.ball.x += ballGameState.ball.vx;
          ballGameState.ball.y += ballGameState.ball.vy;

          // Bounce off walls
          if (ballGameState.ball.x - ballGameState.ball.radius < 0 || ballGameState.ball.x + ballGameState.ball.radius > ballGameState.canvas.width) {
            ballGameState.ball.vx = -ballGameState.ball.vx;
            ballGameState.ball.x = Math.max(ballGameState.ball.radius, Math.min(ballGameState.ball.x, ballGameState.canvas.width - ballGameState.ball.radius));
          }
          if (ballGameState.ball.y - ballGameState.ball.radius < 0) {
            ballGameState.ball.vy = -ballGameState.ball.vy;
          }

          // Ball hit bottom - game over
          if (ballGameState.ball.y > ballGameState.canvas.height) {
            endBouncingBallGame();
            return;
          }

          // Check paddle collision with better physics
          if (ballGameState.ball.y + ballGameState.ball.radius > ballGameState.paddle.y &&
              ballGameState.ball.y - ballGameState.ball.radius < ballGameState.paddle.y + ballGameState.paddle.height &&
              ballGameState.ball.x > ballGameState.paddle.x &&
              ballGameState.ball.x < ballGameState.paddle.x + ballGameState.paddle.width) {
            ballGameState.ball.vy = -Math.abs(ballGameState.ball.vy);
            ballGameState.ball.y = ballGameState.paddle.y - ballGameState.ball.radius;
            
            // Add spin based on where ball hits paddle
            const paddleCenter = ballGameState.paddle.x + ballGameState.paddle.width / 2;
            const hitPos = (ballGameState.ball.x - paddleCenter) / (ballGameState.paddle.width / 2);
            ballGameState.ball.vx += hitPos * 3;
          }

          // Check brick collisions with better detection
          for (let i = 0; i < ballGameState.bricks.length; i++) {
            const brick = ballGameState.bricks[i];
            if (!brick.active) continue;
            
            // Simple AABB collision detection
            if (ballGameState.ball.x + ballGameState.ball.radius > brick.x &&
                ballGameState.ball.x - ballGameState.ball.radius < brick.x + brick.width &&
                ballGameState.ball.y + ballGameState.ball.radius > brick.y &&
                ballGameState.ball.y - ballGameState.ball.radius < brick.y + brick.height) {
              
              brick.active = false;
              ballGameState.bricksDestroyed++;
              ballGameState.score += 10;
              document.getElementById('ballScore').textContent = ballGameState.score;
              
              // Determine collision side and bounce accordingly
              const overlapLeft = (ballGameState.ball.x + ballGameState.ball.radius) - brick.x;
              const overlapRight = (brick.x + brick.width) - (ballGameState.ball.x - ballGameState.ball.radius);
              const overlapTop = (ballGameState.ball.y + ballGameState.ball.radius) - brick.y;
              const overlapBottom = (brick.y + brick.height) - (ballGameState.ball.y - ballGameState.ball.radius);
              
              const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
              
              if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                ballGameState.ball.vx = -ballGameState.ball.vx;
              } else {
                ballGameState.ball.vy = -ballGameState.ball.vy;
              }
              
              // Check if all bricks destroyed - next level!
              if (ballGameState.bricksDestroyed >= ballGameState.totalBricks) {
                ballGameState.level++;
                ballGameState.paddle.width = Math.max(35, 50 - ballGameState.level * 1.5);
                const baseSpeed = 3.5 + (ballGameState.level - 1) * 0.7;
                ballGameState.ball = {x: 200, y: 300, radius: 6, vx: baseSpeed * 0.7, vy: -baseSpeed};
                initBallGame();
              }
            }
          }

          // Draw background
          ballGameState.ctx.fillStyle = '#1a1a2e';
          ballGameState.ctx.fillRect(0, 0, ballGameState.canvas.width, ballGameState.canvas.height);

          // Draw level info
          ballGameState.ctx.fillStyle = '#fff';
          ballGameState.ctx.font = 'bold 14px Arial';
          ballGameState.ctx.fillText(`Level: ${ballGameState.level}`, 10, 20);

          // Draw bricks with colors and borders
          for (let brick of ballGameState.bricks) {
            if (brick.active) {
              ballGameState.ctx.fillStyle = brick.color;
              ballGameState.ctx.fillRect(brick.x + 1, brick.y + 1, brick.width - 2, brick.height - 2);
              
              // Brick border/highlight
              ballGameState.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              ballGameState.ctx.lineWidth = 1;
              ballGameState.ctx.strokeRect(brick.x + 1, brick.y + 1, brick.width - 2, brick.height - 2);
            }
          }

          // Draw paddle with gradient
          const paddleGradient = ballGameState.ctx.createLinearGradient(ballGameState.paddle.x, ballGameState.paddle.y, ballGameState.paddle.x, ballGameState.paddle.y + ballGameState.paddle.height);
          paddleGradient.addColorStop(0, '#00CEC9');
          paddleGradient.addColorStop(1, '#0084B4');
          ballGameState.ctx.fillStyle = paddleGradient;
          ballGameState.ctx.fillRect(ballGameState.paddle.x, ballGameState.paddle.y, ballGameState.paddle.width, ballGameState.paddle.height);
          
          // Paddle border
          ballGameState.ctx.strokeStyle = '#fff';
          ballGameState.ctx.lineWidth = 2;
          ballGameState.ctx.strokeRect(ballGameState.paddle.x, ballGameState.paddle.y, ballGameState.paddle.width, ballGameState.paddle.height);

          // Draw ball with glow
          ballGameState.ctx.fillStyle = '#FFD700';
          ballGameState.ctx.shadowColor = '#FFD700';
          ballGameState.ctx.shadowBlur = 10;
          ballGameState.ctx.beginPath();
          ballGameState.ctx.arc(ballGameState.ball.x, ballGameState.ball.y, ballGameState.ball.radius, 0, Math.PI * 2);
          ballGameState.ctx.fill();
          ballGameState.ctx.shadowBlur = 0;

          requestAnimationFrame(ballGameLoop);
        }

        function endBouncingBallGame() {
          ballGameState.running = false;
          document.removeEventListener('mousemove', handleBallMouseMove);
          document.removeEventListener('touchmove', handleBallTouchMove);

          if (ballGameState.score > ballGameState.highscore) {
            ballGameState.highscore = ballGameState.score;
            localStorage.setItem('ballHighscore', ballGameState.highscore);
            document.getElementById('ballHighscore').textContent = ballGameState.highscore;
            
            // Send highscore to all users via Socket.io
            const highscoreMessage = `üèÜ ${currentUser.name} got a new Bouncing Ball highscore: ${ballGameState.score}!`;
            socket.emit('chat message', { 
              msg: highscoreMessage, 
              room,
              sender: 'Game',
              color: '#FFD700',
              isSystemMessage: true,
              noNotification: true
            });
          }
        }

        // ============ SNAKE GAME ============
        let snakeGameState = {
          canvas: document.getElementById('snakeCanvas'),
          ctx: null,
          snake: [{x: 200, y: 200}],
          food: {x: Math.floor(Math.random() * 20) * 20, y: Math.floor(Math.random() * 20) * 20},
          direction: {x: 1, y: 0},
          nextDirection: {x: 1, y: 0},
          score: 0,
          highscore: localStorage.getItem('snakeHighscore') || 0,
          running: false,
          gameRunning: false,
          gridSize: 20,
          gameSpeed: 8,
          frameCount: 0
        };

        snakeGameState.ctx = snakeGameState.canvas.getContext('2d');

        function startSnakeGame() {
          // First, remove all previous event listeners to prevent conflicts
          const oldCanvas = snakeGameState.canvas;
          const newCanvas = oldCanvas.cloneNode(true);
          oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
          snakeGameState.canvas = newCanvas;
          snakeGameState.ctx = snakeGameState.canvas.getContext('2d');
          
          snakeGameState.snake = [{x: 200, y: 200}];
          snakeGameState.direction = {x: 1, y: 0};
          snakeGameState.nextDirection = {x: 1, y: 0};
          snakeGameState.score = 0;
          snakeGameState.gameSpeed = 8;
          snakeGameState.frameCount = 0;
          snakeGameState.running = true;
          snakeGameState.gameRunning = true;
          document.getElementById('snakeScore').textContent = '0';
          document.getElementById('snakeLength').textContent = '1';
          document.getElementById('snakeDifficultyText').textContent = 'Easy';
          document.getElementById('difficultyFill').style.width = '0%';
          
          // Hide and disable the overlay completely
          const overlay = document.getElementById('snakeGameOverOverlay');
          overlay.style.display = 'none';
          overlay.style.pointerEvents = 'none';
          
          // Hide play button
          document.getElementById('snakePlayBtn').style.display = 'none';
          
          // Prevent scrolling during game
          document.body.style.overflow = 'hidden';
          document.documentElement.style.overflow = 'hidden';
          
          // Setup keyboard controls
          document.addEventListener('keydown', handleSnakeKeydown);
          
          // Setup touch swipe controls directly on canvas
          const canvas = snakeGameState.canvas;
          let touchStartX = 0;
          let touchStartY = 0;
          
          canvas.addEventListener('touchstart', (e) => {
            if (!snakeGameState.running) return;
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
          }, { passive: false });
          
          canvas.addEventListener('touchend', (e) => {
            if (!snakeGameState.running) return;
            e.preventDefault();
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            handleSnakeSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
          }, { passive: false });
          
          canvas.addEventListener('touchmove', (e) => {
            if (!snakeGameState.running) return;
            e.preventDefault();
          }, { passive: false });
          
          snakeGameLoop();
        }

        function handleSnakeSwipe(startX, startY, endX, endY) {
          const deltaX = endX - startX;
          const deltaY = endY - startY;
          const minSwipeDistance = 30;

          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            // Horizontal swipe
            if (deltaX > minSwipeDistance && snakeGameState.direction.x === 0) {
              snakeGameState.nextDirection = {x: 1, y: 0}; // Right
            } else if (deltaX < -minSwipeDistance && snakeGameState.direction.x === 0) {
              snakeGameState.nextDirection = {x: -1, y: 0}; // Left
            }
          } else {
            // Vertical swipe
            if (deltaY > minSwipeDistance && snakeGameState.direction.y === 0) {
              snakeGameState.nextDirection = {x: 0, y: 1}; // Down
            } else if (deltaY < -minSwipeDistance && snakeGameState.direction.y === 0) {
              snakeGameState.nextDirection = {x: 0, y: -1}; // Up
            }
          }
        }

        function handleSnakeMobileControl(direction) {
          if (!snakeGameState.running) return;
          
          // Prevent moving backwards into itself
          if (direction === 'up' && snakeGameState.direction.y === 0) {
            snakeGameState.nextDirection = {x: 0, y: -1};
          } else if (direction === 'down' && snakeGameState.direction.y === 0) {
            snakeGameState.nextDirection = {x: 0, y: 1};
          } else if (direction === 'left' && snakeGameState.direction.x === 0) {
            snakeGameState.nextDirection = {x: -1, y: 0};
          } else if (direction === 'right' && snakeGameState.direction.x === 0) {
            snakeGameState.nextDirection = {x: 1, y: 0};
          }
        }

        function handleSnakeKeydown(e) {
          if (!snakeGameState.running) return;
          
          const key = e.key.toLowerCase();
          
          // Prevent moving backwards into itself
          if (key === 'arrowup' || key === 'w') {
            if (snakeGameState.direction.y === 0) snakeGameState.nextDirection = {x: 0, y: -1};
            e.preventDefault();
          } else if (key === 'arrowdown' || key === 's') {
            if (snakeGameState.direction.y === 0) snakeGameState.nextDirection = {x: 0, y: 1};
            e.preventDefault();
          } else if (key === 'arrowleft' || key === 'a') {
            if (snakeGameState.direction.x === 0) snakeGameState.nextDirection = {x: -1, y: 0};
            e.preventDefault();
          } else if (key === 'arrowright' || key === 'd') {
            if (snakeGameState.direction.x === 0) snakeGameState.nextDirection = {x: 1, y: 0};
            e.preventDefault();
          }
        }

        function snakeGameLoop() {
          if (!snakeGameState.running) return;

          snakeGameState.frameCount++;
          
          // Only update snake position every N frames (game speed control)
          if (snakeGameState.frameCount < snakeGameState.gameSpeed) {
            // Draw while waiting
            drawSnakeGame();
            requestAnimationFrame(snakeGameLoop);
            return;
          }
          
          snakeGameState.frameCount = 0;

          // Update direction
          snakeGameState.direction = snakeGameState.nextDirection;
          
          // Calculate new head position
          const head = snakeGameState.snake[0];
          const newHead = {
            x: head.x + snakeGameState.direction.x * snakeGameState.gridSize,
            y: head.y + snakeGameState.direction.y * snakeGameState.gridSize
          };

          // Check wall collision
          if (newHead.x < 0 || newHead.x >= snakeGameState.canvas.width || 
              newHead.y < 0 || newHead.y >= snakeGameState.canvas.height) {
            endSnakeGame();
            return;
          }

          // Check self collision
          for (let segment of snakeGameState.snake) {
            if (newHead.x === segment.x && newHead.y === segment.y) {
              endSnakeGame();
              return;
            }
          }

          snakeGameState.snake.unshift(newHead);

          // Check food collision
          if (newHead.x === snakeGameState.food.x && newHead.y === snakeGameState.food.y) {
            snakeGameState.score += 10;
            document.getElementById('snakeScore').textContent = snakeGameState.score;
            
            // Update length display
            document.getElementById('snakeLength').textContent = snakeGameState.snake.length + 1;
            
            // Increase difficulty as snake grows
            snakeGameState.gameSpeed = Math.max(3, 8 - Math.floor(snakeGameState.snake.length / 5));
            updateDifficultyDisplay();
            
            snakeGameState.food = {
              x: Math.floor(Math.random() * (snakeGameState.canvas.width / snakeGameState.gridSize)) * snakeGameState.gridSize,
              y: Math.floor(Math.random() * (snakeGameState.canvas.height / snakeGameState.gridSize)) * snakeGameState.gridSize
            };
          } else {
            snakeGameState.snake.pop();
          }

          drawSnakeGame();
          requestAnimationFrame(snakeGameLoop);
        }

        function updateDifficultyDisplay() {
          // Calculate difficulty (1-5) based on snake length
          const difficulty = Math.min(5, Math.ceil(snakeGameState.snake.length / 3));
          const difficultyTexts = ['Easy', 'Normal', 'Hard', 'Very Hard', 'Extreme', 'Insane'];
          const difficultyText = difficultyTexts[difficulty - 1] || 'Insane';
          const difficultyPercent = (difficulty / 5) * 100;
          
          document.getElementById('snakeDifficultyText').textContent = difficultyText;
          document.getElementById('difficultyFill').style.width = difficultyPercent + '%';
        }

        function drawSnakeGame() {
          // Draw background
          snakeGameState.ctx.fillStyle = '#1a1a2e';
          snakeGameState.ctx.fillRect(0, 0, snakeGameState.canvas.width, snakeGameState.canvas.height);

          // Draw grid
          snakeGameState.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
          snakeGameState.ctx.lineWidth = 0.5;
          for (let i = 0; i <= snakeGameState.canvas.width; i += snakeGameState.gridSize) {
            snakeGameState.ctx.beginPath();
            snakeGameState.ctx.moveTo(i, 0);
            snakeGameState.ctx.lineTo(i, snakeGameState.canvas.height);
            snakeGameState.ctx.stroke();
            snakeGameState.ctx.beginPath();
            snakeGameState.ctx.moveTo(0, i);
            snakeGameState.ctx.lineTo(snakeGameState.canvas.width, i);
            snakeGameState.ctx.stroke();
          }

          // Draw snake with head highlight
          for (let i = 0; i < snakeGameState.snake.length; i++) {
            const segment = snakeGameState.snake[i];
            if (i === 0) {
              // Head - brighter color with glow
              snakeGameState.ctx.fillStyle = '#00FF00';
              snakeGameState.ctx.shadowColor = '#00FF00';
              snakeGameState.ctx.shadowBlur = 8;
            } else {
              // Body - darker green with gradient
              const opacity = 1 - (i / snakeGameState.snake.length) * 0.3;
              snakeGameState.ctx.fillStyle = `rgba(100, 200, 100, ${opacity})`;
              snakeGameState.ctx.shadowBlur = 0;
            }
            snakeGameState.ctx.fillRect(segment.x + 1, segment.y + 1, snakeGameState.gridSize - 2, snakeGameState.gridSize - 2);
          }
          snakeGameState.ctx.shadowBlur = 0;

          // Draw food with pulsing effect
          const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
          snakeGameState.ctx.fillStyle = `rgba(255, 107, 107, ${pulse})`;
          snakeGameState.ctx.shadowColor = '#FF6B6B';
          snakeGameState.ctx.shadowBlur = 8;
          snakeGameState.ctx.beginPath();
          const foodSize = (snakeGameState.gridSize - 2) * 0.6;
          snakeGameState.ctx.arc(
            snakeGameState.food.x + snakeGameState.gridSize / 2,
            snakeGameState.food.y + snakeGameState.gridSize / 2,
            foodSize / 2,
            0,
            Math.PI * 2
          );
          snakeGameState.ctx.fill();
          snakeGameState.ctx.shadowBlur = 0;
        }

        function endSnakeGame() {
          snakeGameState.running = false;
          document.removeEventListener('keydown', handleSnakeKeydown);
          
          // Show game over overlay with proper pointer events
          const overlay = document.getElementById('snakeGameOverOverlay');
          overlay.style.pointerEvents = 'auto';
          overlay.style.display = 'flex';
          document.getElementById('finalScore').textContent = snakeGameState.score;
          document.getElementById('finalLength').textContent = snakeGameState.snake.length;
          
          const newHighscoreMsg = document.getElementById('newHighscoreMsg');
          const isNewHighscore = snakeGameState.score > snakeGameState.highscore;
          newHighscoreMsg.style.display = isNewHighscore ? 'block' : 'none';
          
          // Restore scrolling immediately
          document.body.style.overflow = 'auto';
          document.documentElement.style.overflow = 'auto';
          
          // Show play button after overlay is visible
          setTimeout(() => {
            document.getElementById('snakePlayBtn').style.display = 'block';
          }, 200);

          if (isNewHighscore) {
            snakeGameState.highscore = snakeGameState.score;
            localStorage.setItem('snakeHighscore', snakeGameState.highscore);
            document.getElementById('snakeHighscore').textContent = snakeGameState.highscore;
            
            // Send highscore to all users via Socket.io
            const highscoreMessage = `üèÜ ${currentUser.name} got a new Snake highscore: ${snakeGameState.score}!`;
            socket.emit('chat message', { 
              msg: highscoreMessage, 
              room,
              sender: 'Game',
              color: '#FFD700',
              isSystemMessage: true,
              noNotification: true
            });
          }
        }

        // ============ FLAPPY BIRD GAME ============
        let gameState = {
          canvas: document.getElementById('gameCanvas'),
          ctx: null,
          bird: { x: 50, y: 150, width: 20, height: 20, velocity: 0 },
          pipes: [],
          score: 0,
          highscore: localStorage.getItem('flappyHighscore') || 0,
          gameActive: false,
          gameRunning: false,
          pipeWidth: 60,
          pipeGap: 120,
          gravity: 0.08,
          jumpPower: -2
        };

        function initGame() {
          gameState.ctx = gameState.canvas.getContext('2d');
          gameState.score = 0;
          gameState.bird = { x: 50, y: 150, width: 20, height: 20, velocity: 0 };
          gameState.pipes = [];
          gameState.gameRunning = true;
          gameState.gameActive = true;
          document.getElementById('gameScore').textContent = '0';
          document.getElementById('gameHighscore').textContent = gameState.highscore;
          gameLoop();
        }

        function startGame() {
          initGame();
        }

        function openGameModal() {
          document.getElementById('gameModal').classList.add('show');
          document.getElementById('gameMenu').style.display = 'block';
          document.getElementById('flappybirdGame').style.display = 'none';
          document.getElementById('snakeGame').style.display = 'none';
          document.getElementById('bouncingBallGame').style.display = 'none';
          document.getElementById('pongGame').style.display = 'none';
          document.getElementById('dodgeGame').style.display = 'none';
          document.getElementById('gameHighscore').textContent = gameState.highscore;
          document.getElementById('snakeHighscore').textContent = localStorage.getItem('snakeHighscore') || 0;
          document.getElementById('ballHighscore').textContent = localStorage.getItem('ballHighscore') || 0;
          document.getElementById('pongHighscore').textContent = localStorage.getItem('pongHighscore') || 0;
          document.getElementById('dodgeHighscore').textContent = localStorage.getItem('dodgeHighscore') || 0;
        }

        function selectGame(game) {
          document.getElementById('gameMenu').style.display = 'none';
          if (game === 'flappybird') {
            document.getElementById('flappybirdGame').style.display = 'block';
            document.getElementById('snakeGame').style.display = 'none';
            document.getElementById('bouncingBallGame').style.display = 'none';
            document.getElementById('pongGame').style.display = 'none';
            document.getElementById('dodgeGame').style.display = 'none';
          } else if (game === 'snake') {
            document.getElementById('snakeGame').style.display = 'block';
            document.getElementById('flappybirdGame').style.display = 'none';
            document.getElementById('bouncingBallGame').style.display = 'none';
            document.getElementById('pongGame').style.display = 'none';
            document.getElementById('dodgeGame').style.display = 'none';
            // Reset snake game UI state when returning to snake game screen
            document.getElementById('snakePlayBtn').style.display = 'block';
            document.getElementById('snakeGameOverOverlay').style.display = 'none';
            document.getElementById('snakeGameOverOverlay').style.pointerEvents = 'none';
            snakeGameState.running = false;
          } else if (game === 'bouncingball') {
            document.getElementById('bouncingBallGame').style.display = 'block';
            document.getElementById('flappybirdGame').style.display = 'none';
            document.getElementById('snakeGame').style.display = 'none';
            document.getElementById('pongGame').style.display = 'none';
            document.getElementById('dodgeGame').style.display = 'none';
          } else if (game === 'pong') {
            document.getElementById('pongGame').style.display = 'block';
            document.getElementById('flappybirdGame').style.display = 'none';
            document.getElementById('snakeGame').style.display = 'none';
            document.getElementById('bouncingBallGame').style.display = 'none';
            document.getElementById('dodgeGame').style.display = 'none';
          } else if (game === 'dodge') {
            document.getElementById('dodgeGame').style.display = 'block';
            document.getElementById('flappybirdGame').style.display = 'none';
            document.getElementById('snakeGame').style.display = 'none';
            document.getElementById('bouncingBallGame').style.display = 'none';
            document.getElementById('pongGame').style.display = 'none';
          }
        }

        function backToGameMenu() {
          document.getElementById('gameMenu').style.display = 'block';
          document.getElementById('flappybirdGame').style.display = 'none';
          document.getElementById('snakeGame').style.display = 'none';
          document.getElementById('bouncingBallGame').style.display = 'none';
          document.getElementById('pongGame').style.display = 'none';
          document.getElementById('dodgeGame').style.display = 'none';
          gameState.gameRunning = false;
          snakeGameState.running = false;
          // Hide the snake game over overlay when returning to menu
          document.getElementById('snakeGameOverOverlay').style.display = 'none';
          document.getElementById('snakeGameOverOverlay').style.pointerEvents = 'none';
          ballGameState.running = false;
          stopPongGame();
          dodgeGameState.running = false;
        }

        function closeGameModal() {
          document.getElementById('gameModal').classList.remove('show');
          gameState.gameRunning = false;
          snakeGameState.running = false;
          ballGameState.running = false;
          stopPongGame();
          dodgeGameState.running = false;
        }

        function drawBird() {
          gameState.ctx.fillStyle = '#FFD700';
          gameState.ctx.beginPath();
          gameState.ctx.arc(gameState.bird.x + gameState.bird.width / 2, gameState.bird.y + gameState.bird.height / 2, gameState.bird.width / 2, 0, Math.PI * 2);
          gameState.ctx.fill();
          
          // Eyes
          gameState.ctx.fillStyle = 'white';
          gameState.ctx.beginPath();
          gameState.ctx.arc(gameState.bird.x + 12, gameState.bird.y + 8, 3, 0, Math.PI * 2);
          gameState.ctx.fill();
          gameState.ctx.fillStyle = 'black';
          gameState.ctx.beginPath();
          gameState.ctx.arc(gameState.bird.x + 12, gameState.bird.y + 8, 1.5, 0, Math.PI * 2);
          gameState.ctx.fill();
        }

        function drawPipes() {
          gameState.ctx.fillStyle = '#228B22';
          gameState.pipes.forEach(pipe => {
            gameState.ctx.fillRect(pipe.x, 0, gameState.pipeWidth, pipe.topHeight);
            gameState.ctx.fillRect(pipe.x, pipe.topHeight + gameState.pipeGap, gameState.pipeWidth, gameState.canvas.height - pipe.topHeight - gameState.pipeGap);
          });
        }

        function updateGame() {
          gameState.bird.velocity += gameState.gravity;
          gameState.bird.y += gameState.bird.velocity;

          // Generate pipes
          if (gameState.pipes.length === 0 || gameState.pipes[gameState.pipes.length - 1].x < gameState.canvas.width - 150) {
            const minHeight = 50;
            const maxHeight = gameState.canvas.height - gameState.pipeGap - 50;
            const randomHeight = Math.random() * (maxHeight - minHeight) + minHeight;
            gameState.pipes.push({ x: gameState.canvas.width, topHeight: randomHeight });
          }

          // Move pipes
          gameState.pipes = gameState.pipes.filter(pipe => {
            pipe.x -= 1.5;
            if (pipe.x + gameState.pipeWidth < gameState.bird.x && !pipe.scored) {
              pipe.scored = true;
              gameState.score++;
              document.getElementById('gameScore').textContent = gameState.score;
            }
            return pipe.x > -gameState.pipeWidth;
          });

          // Collision detection
          if (gameState.bird.y + gameState.bird.height > gameState.canvas.height || gameState.bird.y < 0) {
            endGame();
            return;
          }

          gameState.pipes.forEach(pipe => {
            if (
              gameState.bird.x < pipe.x + gameState.pipeWidth &&
              gameState.bird.x + gameState.bird.width > pipe.x &&
              (gameState.bird.y < pipe.topHeight || gameState.bird.y + gameState.bird.height > pipe.topHeight + gameState.pipeGap)
            ) {
              endGame();
            }
          });
        }

        function endGame() {
          gameState.gameRunning = false;
          if (gameState.score > gameState.highscore) {
            gameState.highscore = gameState.score;
            localStorage.setItem('flappyHighscore', gameState.highscore);
            document.getElementById('gameHighscore').textContent = gameState.highscore;
            
            // Send highscore to all users via Socket.io
            const highscoreMessage = `üèÜ ${currentUser.name} got a new Flappy Bird highscore: ${gameState.score}!`;
            socket.emit('chat message', { 
              msg: highscoreMessage, 
              room,
              sender: 'Game',
              color: '#FFD700',
              isSystemMessage: true,
              noNotification: true
            });
          }
        }

        function gameLoop() {
          if (!gameState.gameRunning) return;

          gameState.ctx.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);
          
          updateGame();
          drawPipes();
          drawBird();

          requestAnimationFrame(gameLoop);
        }

        // Game controls
        document.getElementById('gameCanvas').addEventListener('click', () => {
          if (gameState.gameRunning) {
            gameState.bird.velocity = gameState.jumpPower;
          }
        });

        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && document.getElementById('gameModal').classList.contains('show')) {
            e.preventDefault();
            if (gameState.gameRunning) {
              gameState.bird.velocity = gameState.jumpPower;
            }
          }
        });

        // Touch support for mobile
        document.getElementById('gameCanvas').addEventListener('touchstart', () => {
          if (gameState.gameRunning) {
            gameState.bird.velocity = gameState.jumpPower;
          }
        }, { passive: true });

        // ============ PONG GAME ============
        let pongGameState = {
          canvas: document.getElementById('pongCanvas'),
          ctx: null,
          playerPaddle: {x: 10, y: 175, width: 10, height: 50, speed: 5},
          aiPaddle: {x: 380, y: 175, width: 10, height: 50, speed: 8},
          ball: {x: 200, y: 200, radius: 5, vx: 3, vy: 3},
          score: 0,
          aiScore: 0,
          highscore: localStorage.getItem('pongHighscore') || 0,
          running: false,
          gameRunning: false,
          playerDir: 0,
          playerCooldown: 0,
          aiCooldown: 0,
          rafId: null,
          lastTs: null
        };

        pongGameState.ctx = pongGameState.canvas.getContext('2d');

        function stopPongGame() {
          // Idempotent cleanup to avoid duplicate RAF loops and event listeners
          pongGameState.running = false;
          pongGameState.gameRunning = false;
          pongGameState.playerDir = 0;

          if (pongGameState.rafId !== null) {
            cancelAnimationFrame(pongGameState.rafId);
            pongGameState.rafId = null;
          }

          document.removeEventListener('keydown', handlePongKeydown);
          document.removeEventListener('keyup', handlePongKeyup);
          document.removeEventListener('mousemove', handlePongMouseMove);
          document.removeEventListener('touchmove', handlePongTouchMove);
        }

        function startPongGame() {
          // Prevent stacking multiple games (double-click / reopen modal)
          stopPongGame();

          pongGameState.score = 0;
          pongGameState.aiScore = 0;
          pongGameState.running = true;
          pongGameState.gameRunning = true;
          pongGameState.playerDir = 0;
          pongGameState.playerCooldown = 0;
          pongGameState.aiCooldown = 0;
          pongGameState.lastTs = null;
          pongGameState.playerPaddle = {x: 10, y: 175, width: 10, height: 50, speed: 5};
          pongGameState.aiPaddle = {x: 380, y: 175, width: 10, height: 50, speed: 8};
          const randomVx = (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 2);
          const randomVy = (Math.random() - 0.5) * 4;
          pongGameState.ball = {x: 200, y: 200, radius: 5, vx: randomVx, vy: randomVy};
          document.getElementById('pongScore').textContent = '0';
          
          // Hide mobile control buttons - using mouse/touch following instead
          document.getElementById('pongMobileControls').style.display = 'none';
          
          document.addEventListener('keydown', handlePongKeydown);
          document.addEventListener('keyup', handlePongKeyup);
          document.addEventListener('mousemove', handlePongMouseMove);
          document.addEventListener('touchmove', handlePongTouchMove);

          pongGameState.rafId = requestAnimationFrame(pongGameLoop);
        }

        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        function checkPongPaddleCollision(prevX, paddle, isPlayer) {
          const r = pongGameState.ball.radius;

          // Only check collision when moving towards the paddle.
          if (isPlayer) {
            if (pongGameState.ball.vx >= 0 || pongGameState.playerCooldown > 0) return;
            const paddleLine = paddle.x + paddle.width;
            if (prevX + r > paddleLine && pongGameState.ball.x + r <= paddleLine) {
              if (pongGameState.ball.y > paddle.y - r && pongGameState.ball.y < paddle.y + paddle.height + r) {
                const impactPosRaw = (pongGameState.ball.y - paddle.y) / paddle.height;
                const impactPos = clamp(impactPosRaw, 0, 1);
                pongGameState.ball.x = paddleLine + r + 1;
                pongGameState.ball.vx = Math.abs(pongGameState.ball.vx) * 1.05;
                pongGameState.ball.vy += (impactPos - 0.5) * 2;
                pongGameState.playerCooldown = 5;
              }
            }
          } else {
            if (pongGameState.ball.vx <= 0 || pongGameState.aiCooldown > 0) return;
            const paddleLine = paddle.x;
            if (prevX - r < paddleLine && pongGameState.ball.x - r >= paddleLine) {
              if (pongGameState.ball.y > paddle.y - r && pongGameState.ball.y < paddle.y + paddle.height + r) {
                const impactPosRaw = (pongGameState.ball.y - paddle.y) / paddle.height;
                const impactPos = clamp(impactPosRaw, 0, 1);
                pongGameState.ball.x = paddleLine - r - 1;
                pongGameState.ball.vx = -Math.abs(pongGameState.ball.vx) * 1.05;
                pongGameState.ball.vy += (impactPos - 0.5) * 2;
                pongGameState.aiCooldown = 5;
              }
            }
          }
        }

        function handlePongMouseMove(e) {
          if (!pongGameState.running) return;
          const rect = pongGameState.canvas.getBoundingClientRect();
          const scaleY = pongGameState.canvas.height / rect.height;
          const y = (e.clientY - rect.top) * scaleY;
          pongGameState.playerPaddle.y = Math.max(0, Math.min(y - pongGameState.playerPaddle.height / 2, pongGameState.canvas.height - pongGameState.playerPaddle.height));
        }

        function handlePongTouchMove(e) {
          if (!pongGameState.running) return;
          const rect = pongGameState.canvas.getBoundingClientRect();
          const scaleY = pongGameState.canvas.height / rect.height;
          const y = (e.touches[0].clientY - rect.top) * scaleY;
          pongGameState.playerPaddle.y = Math.max(0, Math.min(y - pongGameState.playerPaddle.height / 2, pongGameState.canvas.height - pongGameState.playerPaddle.height));
        }

        function handlePongKeydown(e) {
          if (!pongGameState.running) return;
          const key = e.key.toLowerCase();
          if (key === 'w' || key === 'arrowup') pongGameState.playerDir = -1;
          else if (key === 's' || key === 'arrowdown') pongGameState.playerDir = 1;
        }

        function handlePongKeyup(e) {
          if (!pongGameState.running) return;
          const key = e.key.toLowerCase();
          if ((key === 'w' || key === 'arrowup' || key === 's' || key === 'arrowdown')) {
            pongGameState.playerDir = 0;
          }
        }

        function handlePongMobileControl(direction) {
          if (!pongGameState.running) return;
          pongGameState.playerDir = direction === 'up' ? -1 : 1;
        }

        function pongGameLoop(ts) {
          if (!pongGameState.running) {
            pongGameState.rafId = null;
            return;
          }

          // Delta-time: keep same speed at 60fps, but avoid huge steps when tab stutters.
          if (pongGameState.lastTs === null) pongGameState.lastTs = ts;
          const dtMsRaw = ts - pongGameState.lastTs;
          pongGameState.lastTs = ts;
          const dtMs = clamp(dtMsRaw, 0, 50);
          const dtFactor = dtMs / (1000 / 60);

          // Move player paddle
          pongGameState.playerPaddle.y += pongGameState.playerDir * pongGameState.playerPaddle.speed;
          pongGameState.playerPaddle.y = Math.max(0, Math.min(pongGameState.playerPaddle.y, pongGameState.canvas.height - pongGameState.playerPaddle.height));

          // AI paddle - predict where ball will be
          const aiCenter = pongGameState.aiPaddle.y + pongGameState.aiPaddle.height / 2;
          
          // Predict where ball will be when it reaches AI paddle
          let predictedBallY = pongGameState.ball.y;
          if (pongGameState.ball.vx > 0) {
            // Ball moving towards AI - calculate frames until it reaches paddle
            const distanceToAI = pongGameState.aiPaddle.x - pongGameState.ball.x;
            const framesUntilImpact = distanceToAI / pongGameState.ball.vx;
            predictedBallY = pongGameState.ball.y + (pongGameState.ball.vy * framesUntilImpact);
            
            // Clamp predicted position to canvas bounds
            predictedBallY = Math.max(pongGameState.ball.radius, Math.min(pongGameState.canvas.height - pongGameState.ball.radius, predictedBallY));
          }
          
          // Move AI paddle towards predicted ball position with smaller dead zone
          const deadZone = 15;
          if (aiCenter < predictedBallY - deadZone) {
            pongGameState.aiPaddle.y += pongGameState.aiPaddle.speed;
          } else if (aiCenter > predictedBallY + deadZone) {
            pongGameState.aiPaddle.y -= pongGameState.aiPaddle.speed;
          }
          pongGameState.aiPaddle.y = Math.max(0, Math.min(pongGameState.aiPaddle.y, pongGameState.canvas.height - pongGameState.aiPaddle.height));

          // Limit ball velocity to prevent tunneling
          const maxVelocity = 6;
          pongGameState.ball.vx = Math.max(-maxVelocity, Math.min(maxVelocity, pongGameState.ball.vx));
          pongGameState.ball.vy = Math.max(-maxVelocity, Math.min(maxVelocity, pongGameState.ball.vy));

          // Substep integration: prevents missing collisions even if dt spikes.
          const dx = pongGameState.ball.vx * dtFactor;
          const dy = pongGameState.ball.vy * dtFactor;
          const maxStep = 2;
          const requestedSteps = Math.ceil(Math.max(Math.abs(dx), Math.abs(dy)) / maxStep);
          const steps = clamp(requestedSteps || 1, 1, 10);
          const stepX = dx / steps;
          const stepY = dy / steps;

          for (let step = 0; step < steps; step++) {
            const prevBallX = pongGameState.ball.x;

            // Move ball (small step)
            pongGameState.ball.x += stepX;
            pongGameState.ball.y += stepY;

            // Ball bounce off top/bottom with clamping
            if (pongGameState.ball.y - pongGameState.ball.radius < 0) {
              pongGameState.ball.y = pongGameState.ball.radius;
              pongGameState.ball.vy = -pongGameState.ball.vy;
            } else if (pongGameState.ball.y + pongGameState.ball.radius > pongGameState.canvas.height) {
              pongGameState.ball.y = pongGameState.canvas.height - pongGameState.ball.radius;
              pongGameState.ball.vy = -pongGameState.ball.vy;
            }

            // Paddle collisions (swept test along X for this substep)
            checkPongPaddleCollision(prevBallX, pongGameState.playerPaddle, true);
            checkPongPaddleCollision(prevBallX, pongGameState.aiPaddle, false);

            // Ball out of bounds (score). If scored, reset and stop processing steps.
            if (pongGameState.ball.x < -pongGameState.ball.radius) {
              pongGameState.aiScore++;
              const randomVx = -(3 + Math.random() * 2);
              const randomVy = (Math.random() - 0.5) * 3;
              pongGameState.ball = {x: 200, y: 200, radius: 5, vx: randomVx, vy: randomVy};
              pongGameState.playerCooldown = 0;
              pongGameState.aiCooldown = 0;
              break;
            } else if (pongGameState.ball.x > pongGameState.canvas.width + pongGameState.ball.radius) {
              pongGameState.score++;
              document.getElementById('pongScore').textContent = pongGameState.score;
              const randomVx = 3 + Math.random() * 2;
              const randomVy = (Math.random() - 0.5) * 3;
              pongGameState.ball = {x: 200, y: 200, radius: 5, vx: randomVx, vy: randomVy};
              pongGameState.playerCooldown = 0;
              pongGameState.aiCooldown = 0;
              break;
            }
          }

          // Decrease collision cooldowns
          if (pongGameState.playerCooldown > 0) {
            pongGameState.playerCooldown--;
          }
          if (pongGameState.aiCooldown > 0) {
            pongGameState.aiCooldown--;
          }

          if (pongGameState.aiScore >= 5) {
            endPongGame();
            return;
          }

          // Draw
          // Background with gradient
          const gradient = pongGameState.ctx.createLinearGradient(0, 0, 0, pongGameState.canvas.height);
          gradient.addColorStop(0, '#0a0a0f');
          gradient.addColorStop(1, '#1a1a2e');
          pongGameState.ctx.fillStyle = gradient;
          pongGameState.ctx.fillRect(0, 0, pongGameState.canvas.width, pongGameState.canvas.height);

          // Draw center line with glow effect
          pongGameState.ctx.strokeStyle = 'rgba(102, 126, 234, 0.4)';
          pongGameState.ctx.lineWidth = 2;
          pongGameState.ctx.setLineDash([8, 6]);
          pongGameState.ctx.beginPath();
          pongGameState.ctx.moveTo(pongGameState.canvas.width / 2, 0);
          pongGameState.ctx.lineTo(pongGameState.canvas.width / 2, pongGameState.canvas.height);
          pongGameState.ctx.stroke();
          pongGameState.ctx.setLineDash([]);

          // Draw court border
          pongGameState.ctx.strokeStyle = 'rgba(102, 126, 234, 0.6)';
          pongGameState.ctx.lineWidth = 2;
          pongGameState.ctx.strokeRect(1, 1, pongGameState.canvas.width - 2, pongGameState.canvas.height - 2);

          // Draw paddles with glow effect
          const drawPaddle = (paddle, isPlayer) => {
            // Glow effect
            pongGameState.ctx.shadowColor = isPlayer ? 'rgba(67, 233, 123, 0.8)' : 'rgba(255, 107, 107, 0.8)';
            pongGameState.ctx.shadowBlur = 15;
            pongGameState.ctx.shadowOffsetX = 0;
            pongGameState.ctx.shadowOffsetY = 0;
            
            // Paddle gradient
            const paddleGradient = pongGameState.ctx.createLinearGradient(paddle.x, paddle.y, paddle.x + paddle.width, paddle.y);
            paddleGradient.addColorStop(0, isPlayer ? '#43e97b' : '#FF6B6B');
            paddleGradient.addColorStop(1, isPlayer ? '#38b86d' : '#FF4757');
            pongGameState.ctx.fillStyle = paddleGradient;
            
            // Draw rounded paddle
            pongGameState.ctx.beginPath();
            pongGameState.ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 3);
            pongGameState.ctx.fill();
            
            // Paddle highlight
            pongGameState.ctx.fillStyle = isPlayer ? 'rgba(255, 255, 255, 0.3)' : 'rgba(255, 255, 255, 0.2)';
            pongGameState.ctx.fillRect(paddle.x, paddle.y, paddle.width / 2, paddle.height / 4);
            
            pongGameState.ctx.shadowBlur = 0;
          };

          drawPaddle(pongGameState.playerPaddle, true);
          drawPaddle(pongGameState.aiPaddle, false);

          // Draw ball with enhanced effects
          const ballGradient = pongGameState.ctx.createRadialGradient(pongGameState.ball.x - 2, pongGameState.ball.y - 2, 0, pongGameState.ball.x, pongGameState.ball.y, pongGameState.ball.radius);
          ballGradient.addColorStop(0, '#FFFF99');
          ballGradient.addColorStop(1, '#FFD700');
          
          // Ball glow
          pongGameState.ctx.shadowColor = '#FFD700';
          pongGameState.ctx.shadowBlur = 20;
          pongGameState.ctx.fillStyle = ballGradient;
          pongGameState.ctx.beginPath();
          pongGameState.ctx.arc(pongGameState.ball.x, pongGameState.ball.y, pongGameState.ball.radius, 0, Math.PI * 2);
          pongGameState.ctx.fill();
          
          // Ball highlight
          pongGameState.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          pongGameState.ctx.beginPath();
          pongGameState.ctx.arc(pongGameState.ball.x - 2, pongGameState.ball.y - 2, pongGameState.ball.radius * 0.4, 0, Math.PI * 2);
          pongGameState.ctx.fill();
          
          pongGameState.ctx.shadowBlur = 0;

          // Draw scores on canvas with better styling
          pongGameState.ctx.fillStyle = '#43e97b';
          pongGameState.ctx.font = 'bold 32px Arial';
          pongGameState.ctx.textAlign = 'center';
          pongGameState.ctx.shadowColor = 'rgba(67, 233, 123, 0.5)';
          pongGameState.ctx.shadowBlur = 10;
          pongGameState.ctx.fillText(pongGameState.score, pongGameState.canvas.width / 4, 40);
          
          pongGameState.ctx.fillStyle = '#FF6B6B';
          pongGameState.ctx.shadowColor = 'rgba(255, 107, 107, 0.5)';
          pongGameState.ctx.fillText(pongGameState.aiScore, (pongGameState.canvas.width / 4) * 3, 40);
          pongGameState.ctx.shadowBlur = 0;

          pongGameState.rafId = requestAnimationFrame(pongGameLoop);
        }

        function endPongGame() {
          stopPongGame();

          if (pongGameState.score > pongGameState.highscore) {
            pongGameState.highscore = pongGameState.score;
            localStorage.setItem('pongHighscore', pongGameState.highscore);
            document.getElementById('pongHighscore').textContent = pongGameState.highscore;
            
            const highscoreMessage = `üèÜ ${currentUser.name} got a new Pong highscore: ${pongGameState.score}!`;
            socket.emit('chat message', { 
              msg: highscoreMessage, 
              room,
              sender: 'Game',
              color: '#FFD700',
              isSystemMessage: true,
              noNotification: true
            });
          }
        }

        // ============ DODGE GAME ============
        let dodgeGameState = {
          canvas: document.getElementById('dodgeCanvas'),
          ctx: null,
          player: {x: 175, y: 350, width: 50, height: 30, speed: 6},
          obstacles: [],
          score: 0,
          highscore: localStorage.getItem('dodgeHighscore') || 0,
          running: false,
          gameRunning: false,
          playerDir: 0,
          spawnTimer: 0,
          spawnRate: 40
        };

        dodgeGameState.ctx = dodgeGameState.canvas.getContext('2d');

        function startDodgeGame() {
          dodgeGameState.score = 0;
          dodgeGameState.running = true;
          dodgeGameState.gameRunning = true;
          dodgeGameState.player = {x: 175, y: 350, width: 30, height: 30, speed: 6};
          dodgeGameState.obstacles = [];
          dodgeGameState.playerDir = 0;
          dodgeGameState.spawnTimer = 0;
          document.getElementById('dodgeScore').textContent = '0';
          
          // Hide mobile control buttons - using mouse/touch following instead
          document.getElementById('dodgeMobileControls').style.display = 'none';
          
          document.addEventListener('keydown', handleDodgeKeydown);
          document.addEventListener('keyup', handleDodgeKeyup);
          document.addEventListener('mousemove', handleDodgeMouseMove);
          document.addEventListener('touchmove', handleDodgeTouchMove);
          
          dodgeGameLoop();
        }

        function handleDodgeMouseMove(e) {
          if (!dodgeGameState.running) return;
          const rect = dodgeGameState.canvas.getBoundingClientRect();
          const scaleX = dodgeGameState.canvas.width / rect.width;
          const x = (e.clientX - rect.left) * scaleX;
          const centerX = x - dodgeGameState.player.width / 2;
          dodgeGameState.player.x = Math.max(0, Math.min(centerX, dodgeGameState.canvas.width - dodgeGameState.player.width));
        }

        function handleDodgeTouchMove(e) {
          if (!dodgeGameState.running) return;
          const rect = dodgeGameState.canvas.getBoundingClientRect();
          const scaleX = dodgeGameState.canvas.width / rect.width;
          const x = (e.touches[0].clientX - rect.left) * scaleX;
          const centerX = x - dodgeGameState.player.width / 2;
          dodgeGameState.player.x = Math.max(0, Math.min(centerX, dodgeGameState.canvas.width - dodgeGameState.player.width));
        }

        function handleDodgeKeydown(e) {
          if (!dodgeGameState.running) return;
          const key = e.key.toLowerCase();
          if (key === 'a' || key === 'arrowleft') dodgeGameState.playerDir = -1;
          else if (key === 'd' || key === 'arrowright') dodgeGameState.playerDir = 1;
        }

        function handleDodgeKeyup(e) {
          if (!dodgeGameState.running) return;
          const key = e.key.toLowerCase();
          if ((key === 'a' || key === 'arrowleft' || key === 'd' || key === 'arrowright')) {
            dodgeGameState.playerDir = 0;
          }
        }

        function handleDodgeMobileControl(direction) {
          if (!dodgeGameState.running) return;
          dodgeGameState.playerDir = direction === 'left' ? -1 : 1;
        }

        function dodgeGameLoop() {
          if (!dodgeGameState.running) return;

          // Move player
          dodgeGameState.player.x += dodgeGameState.playerDir * dodgeGameState.player.speed;
          dodgeGameState.player.x = Math.max(0, Math.min(dodgeGameState.player.x, dodgeGameState.canvas.width - dodgeGameState.player.width));

          // Spawn obstacles
          dodgeGameState.spawnTimer++;
          if (dodgeGameState.spawnTimer > dodgeGameState.spawnRate) {
            dodgeGameState.obstacles.push({
              x: Math.random() * (dodgeGameState.canvas.width - 30),
              y: -30,
              width: 30,
              height: 30,
              speed: 3 + (dodgeGameState.score / 100)
            });
            dodgeGameState.spawnTimer = 0;
            if (dodgeGameState.spawnRate > 20) dodgeGameState.spawnRate--;
          }

          // Move obstacles
          for (let i = 0; i < dodgeGameState.obstacles.length; i++) {
            dodgeGameState.obstacles[i].y += dodgeGameState.obstacles[i].speed;

            // Collision
            if (dodgeGameState.obstacles[i].x < dodgeGameState.player.x + dodgeGameState.player.width &&
                dodgeGameState.obstacles[i].x + dodgeGameState.obstacles[i].width > dodgeGameState.player.x &&
                dodgeGameState.obstacles[i].y < dodgeGameState.player.y + dodgeGameState.player.height &&
                dodgeGameState.obstacles[i].y + dodgeGameState.obstacles[i].height > dodgeGameState.player.y) {
              endDodgeGame();
              return;
            }

            // Remove if off screen
            if (dodgeGameState.obstacles[i].y > dodgeGameState.canvas.height) {
              dodgeGameState.obstacles.splice(i, 1);
              dodgeGameState.score += 10;
              document.getElementById('dodgeScore').textContent = dodgeGameState.score;
              i--;
            }
          }

          // Draw
          dodgeGameState.ctx.fillStyle = '#1a1a2e';
          dodgeGameState.ctx.fillRect(0, 0, dodgeGameState.canvas.width, dodgeGameState.canvas.height);

          // Draw player
          dodgeGameState.ctx.fillStyle = '#43e97b';
          dodgeGameState.ctx.fillRect(dodgeGameState.player.x, dodgeGameState.player.y, dodgeGameState.player.width, dodgeGameState.player.height);

          // Draw obstacles
          dodgeGameState.ctx.fillStyle = '#fa709a';
          for (let obs of dodgeGameState.obstacles) {
            dodgeGameState.ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
          }

          requestAnimationFrame(dodgeGameLoop);
        }

        function endDodgeGame() {
          dodgeGameState.running = false;
          document.removeEventListener('keydown', handleDodgeKeydown);
          document.removeEventListener('keyup', handleDodgeKeyup);
          document.removeEventListener('mousemove', handleDodgeMouseMove);
          document.removeEventListener('touchmove', handleDodgeTouchMove);

          if (dodgeGameState.score > dodgeGameState.highscore) {
            dodgeGameState.highscore = dodgeGameState.score;
            localStorage.setItem('dodgeHighscore', dodgeGameState.highscore);
            document.getElementById('dodgeHighscore').textContent = dodgeGameState.highscore;
            
            const highscoreMessage = `üèÜ ${currentUser.name} got a new Dodge highscore: ${dodgeGameState.score}!`;
            socket.emit('chat message', { 
              msg: highscoreMessage, 
              room,
              sender: 'Game',
              color: '#FFD700',
              isSystemMessage: true,
              noNotification: true
            });
          }
        }

        // Initialize on load
        checkRoomPassword();
        initializeUser();
        updateUserDisplay();
        requestNotificationPermission();
    </script>
  </body>
</html>
